[["index.html", "Mastering Shiny Book Club Welcome", " Mastering Shiny Book Club The R4DS Online Learning Community 2021-02-17 Welcome This is a companion for the book Mastering Shiny by Hadley Wickham. This companion is available at r4ds.io/mshiny. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book. This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["chapter-title.html", "Chapter 1 Chapter title", " Chapter 1 Chapter title Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title.html", "1.1 {Slide 1 title}", " 1.1 {Slide 1 title} {Create slides as sections, but keep them short like a slide.} "],["meeting-videos.html", "1.2 Meeting Videos", " 1.2 Meeting Videos 1.2.1 Cohort 1 Meeting chat log "],["your-first-shiny-app.html", "Chapter 2 Your first Shiny app", " Chapter 2 Your first Shiny app Learning objectives: Learn how to create a simple Shiny app Define the leanest version of an app you can build Review different ways to start and stop the app Identify the two key components of every Shiny app Understand how the two components are connected Observe how Shiny apps react to user input "],["introduction.html", "2.1 Introduction", " 2.1 Introduction This chapter is basically a quick demo of the minimum boilerplate needed for a Shiny app. It defines the two key components - the ui and the server Then introduces reactive programming - which is how shiny automatically updates outputs when inputs change. Shiny outputs (tables, charts etc.) can automatically react (recalculate) when their inputs change. 2.1.1 If you haven’t installed Shiny already: install.packages(&#39;shiny&#39;) Check you have version 1.5.0 or higher packageVersion(&quot;shiny&quot;) ## [1] &#39;1.6.0&#39; Load shiny library(&#39;shiny&#39;) "],["creating-an-app.html", "2.2 Creating an app", " 2.2 Creating an app Simplest way - create new directory for your app and add a single app.r file library(shiny) ui &lt;- fluidPage( &quot;Hello, world!&quot; ) server &lt;- function(input, output, session) { } shinyApp(ui, server) Looking closely at the code above, this app.r file does four things: Loads shiny Defines the ui - the HTML webpage humans interact with Specifies behaviour of the app in the server Executes shinyApp(ui, server) to construct and start the app "],["running-and-stopping-the-app.html", "2.3 Running and stopping the app", " 2.3 Running and stopping the app The basic workflow of shiny app development is… Write some code Start the app Play with the app Write some more code Repeat… 2.3.1 Running the app There are a few ways you can run your app If using R Studio: Click Run App button in document toolbar Keyboard shortcut is CMD / CTRL + SHIFT + ENTER If not using R Studio: (source()) the whole document or call shiny::runApp() The console message #&gt; Listening on http://127.0.0.1:3827 identifies your app in any (local) web browser. 127.0.0.1 is a standard address = this computer last 4 digits = randomly assigned port number Running a Shiny app keeps R busy and you will not be able to execute other commands in the console at that time. 2.3.2 Stopping the app: STOP sign on console toolbar ESC from within R console (CTRL + C is not in R Studio) Close shiny app window "],["adding-ui-controls.html", "2.4 Adding UI controls", " 2.4 Adding UI controls Replace the ui in your app with this code that shows you all the built-in data frames in the datasets package. ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, label = &quot;Dataset&quot;, choices = ls(&quot;package:datasets&quot;)), verbatimTextOutput(&quot;summary&quot;), tableOutput(&quot;table&quot;) ) Four new functions: fluidPage() - layout function to set up visual structure of page selectInput() - input control for user to interact with verbatimTextOutput() - output control - shows code result tableOutput - output control - displays tables These are all just ways to generate HTML Note: fluidPage() is just one option available for page setup. navBarPage() is a nice example for creating an app with page tabs. "],["adding-behaviour.html", "2.5 Adding behaviour", " 2.5 Adding behaviour Need server function to bring the outputs to life Reactive programming tells Shiny how to perform a function. This code tells shiny how to fill in the summary and table outputs we defined in the UI. server &lt;- function(input, output, session) { output$summary &lt;- renderPrint({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) summary(dataset) }) output$table &lt;- renderTable({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) dataset }) } Each output$out_id is a new shiny output to render where the UI defines it There are specific render functions render{Type} for different outputs: text tables plots images new ui components "],["reactive-expressions.html", "2.6 Reactive expressions", " 2.6 Reactive expressions Key part of reducing duplication and ensuring you D-R-Y Duplicated code is particularly bad for Shiny apps which can get cumbersome and more difficult to maintain and debug as they grow (Although the latest release of shiny does have some improved debugging tools) Reactive expressions combines some of the same logic as variables and functions, but is a bit different as these do not work the same in shiny as normal R programming. Create a reactive expression by wrapping a block of code in reactive({...}) and assigning it to a variable. You can use the reactive expression like a standard function with one important difference - it only runs once and caches the result until input changed. So once it is initialised it will return some form of constant until it’s updated again. The below code retrieves the dataset once, not twice server &lt;- function(input, output, session) { # Create a reactive expression dataset &lt;- reactive({ get(input$dataset, &quot;package:datasets&quot;) }) output$summary &lt;- renderPrint({ # Use a reactive expression by calling it like a function summary(dataset()) }) output$table &lt;- renderTable({ dataset() }) } "],["visualising-reactive-expressions.html", "2.7 Visualising reactive expressions", " 2.7 Visualising reactive expressions The flow visualised in 2.1 now has a middle layer - a reactive expression. Which lives in the server function of the app. The ui to server connections can be visualised like this: Using our ‘first app’ as an example: "],["shiny-resources.html", "2.8 Shiny resources", " 2.8 Shiny resources Shiny cheatsheet https://www.rstudio.com/resources/cheatsheets/ 2.8.1 Other resources Shiny Gallery has lots of inspiration and demos of specific ui components and server behaviours. https://shiny.rstudio.com/gallery/ Shiny Widgets Gallery is included in above link and introduces the main options for inputs in the ui. https://shiny.rstudio.com/gallery/widget-gallery.html Shiny Dashboard is a nice framework for creating good looking and well structured apps with minimal effort. May get limiting as you advance and want more customisation. https://rstudio.github.io/shinydashboard/index.html "],["meeting-videos-1.html", "2.9 Meeting Videos", " 2.9 Meeting Videos 2.9.1 Cohort 1 Meeting chat log "]]
