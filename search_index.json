[["index.html", "Mastering Shiny Book Club Welcome", " Mastering Shiny Book Club The R4DS Online Learning Community 2021-06-01 Welcome This is a companion for the book Mastering Shiny by Hadley Wickham. This companion is available at r4ds.io/mshiny. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book. This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["preface.html", "Preface", " Preface The preface chapter will not be studied as part of the book-club. It provides an overview of the purpose of shiny, a brief description of the main components of a shiny app and an introduction to reactive programming. All these ideas are studied in more detail in the later chapters (hence, why we’ve skipped it). There are some notes on setting up R/RStudio for developing shiny apps, on the packages that should be installed, and some pointers about deploying shiny apps. When shiny-apps are developed as part of the book-club, we will typically deploy them to the R4DS shinyapps.io account. shinyapps.io has a lot of detail on releasing shiny-apps to the world. If you have any questions / problems setting up shiny for local use, or with deployment of a shiny app to shinyapps.io, feel free to ask in either the “book_club-mastering_shiny” or the “help-4-shiny” channel on the R4DS slack. "],["your-first-shiny-app.html", "Chapter 1 Your first Shiny app", " Chapter 1 Your first Shiny app Learning objectives: Learn how to create a simple Shiny app Define the leanest version of an app you can build Review different ways to start and stop the app Identify the two key components of every Shiny app Understand how the two components are connected Observe how Shiny apps react to user input "],["introduction.html", "1.1 Introduction", " 1.1 Introduction This chapter is basically a quick demo of the minimum boilerplate needed for a Shiny app. It defines the two key components - the ui and the server Then introduces reactive programming - which is how shiny automatically updates outputs when inputs change. Shiny outputs (tables, charts etc.) can automatically react (recalculate) when their inputs change. 1.1.1 If you haven’t installed Shiny already: install.packages(&#39;shiny&#39;) Check you have version 1.5.0 or higher packageVersion(&quot;shiny&quot;) ## [1] &#39;1.6.0&#39; Load shiny library(&#39;shiny&#39;) "],["creating-an-app.html", "1.2 Creating an app", " 1.2 Creating an app Simplest way - create new directory for your app and add a single app.r file library(shiny) ui &lt;- fluidPage( &quot;Hello, world!&quot; ) server &lt;- function(input, output, session) { } shinyApp(ui, server) Looking closely at the code above, this app.r file does four things: Loads shiny Defines the ui - the HTML webpage humans interact with Specifies behaviour of the app in the server Executes shinyApp(ui, server) to construct and start the app "],["running-and-stopping-the-app.html", "1.3 Running and stopping the app", " 1.3 Running and stopping the app The basic workflow of shiny app development is… Write some code Start the app Play with the app Write some more code Repeat… 1.3.1 Running the app There are a few ways you can run your app If using R Studio: Click Run App button in document toolbar Keyboard shortcut is CMD / CTRL + SHIFT + ENTER If not using R Studio: (source()) the whole document or call shiny::runApp() The console message #&gt; Listening on http://127.0.0.1:3827 identifies your app in any (local) web browser. 127.0.0.1 is a standard address = this computer last 4 digits = randomly assigned port number Running a Shiny app keeps R busy and you will not be able to execute other commands in the console at that time. 1.3.2 Stopping the app: STOP sign on console toolbar ESC from within R console (CTRL + C is not in R Studio) Close shiny app window "],["adding-ui-controls.html", "1.4 Adding UI controls", " 1.4 Adding UI controls Replace the ui in your app with this code that shows you all the built-in data frames in the datasets package. ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, label = &quot;Dataset&quot;, choices = ls(&quot;package:datasets&quot;)), verbatimTextOutput(&quot;summary&quot;), tableOutput(&quot;table&quot;) ) Four new functions: fluidPage() - layout function to set up visual structure of page selectInput() - input control for user to interact with verbatimTextOutput() - output control - shows code result tableOutput - output control - displays tables These are all just ways to generate HTML Note: fluidPage() is just one option available for page setup. navBarPage() is a nice example for creating an app with page tabs. "],["adding-behaviour.html", "1.5 Adding behaviour", " 1.5 Adding behaviour Need server function to bring the outputs to life Reactive programming tells Shiny how to perform a function. This code tells shiny how to fill in the summary and table outputs we defined in the UI. server &lt;- function(input, output, session) { output$summary &lt;- renderPrint({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) summary(dataset) }) output$table &lt;- renderTable({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) dataset }) } Each output$out_id is a new shiny output to render where the UI defines it There are specific render functions render{Type} for different outputs: text tables plots images new ui components "],["reactive-expressions.html", "1.6 Reactive expressions", " 1.6 Reactive expressions Key part of reducing duplication and ensuring you D-R-Y Duplicated code is particularly bad for Shiny apps which can get cumbersome and more difficult to maintain and debug as they grow (Although the latest release of shiny does have some improved debugging tools) Reactive expressions combines some of the same logic as variables and functions, but is a bit different as these do not work the same in shiny as normal R programming. Create a reactive expression by wrapping a block of code in reactive({...}) and assigning it to a variable. You can use the reactive expression like a standard function with one important difference - it only runs once and caches the result until input changed. So once it is initialised it will return some form of constant until it’s updated again. The below code retrieves the dataset once, not twice server &lt;- function(input, output, session) { # Create a reactive expression dataset &lt;- reactive({ get(input$dataset, &quot;package:datasets&quot;) }) output$summary &lt;- renderPrint({ # Use a reactive expression by calling it like a function summary(dataset()) }) output$table &lt;- renderTable({ dataset() }) } "],["visualising-reactive-expressions.html", "1.7 Visualising reactive expressions", " 1.7 Visualising reactive expressions The flow visualised in 2.1 now has a middle layer - a reactive expression. Which lives in the server function of the app. The ui to server connections can be visualised like this: Using our ‘first app’ as an example: "],["shiny-resources.html", "1.8 Shiny resources", " 1.8 Shiny resources Shiny cheatsheet https://www.rstudio.com/resources/cheatsheets/ 1.8.1 Other resources Shiny Gallery has lots of inspiration and demos of specific ui components and server behaviours. https://shiny.rstudio.com/gallery/ Shiny Widgets Gallery is included in above link and introduces the main options for inputs in the ui. https://shiny.rstudio.com/gallery/widget-gallery.html Shiny Dashboard is a nice framework for creating good looking and well structured apps with minimal effort. May get limiting as you advance and want more customisation. https://rstudio.github.io/shinydashboard/index.html "],["meeting-videos.html", "1.9 Meeting Videos", " 1.9 Meeting Videos 1.9.1 Cohort 1 Meeting chat log "],["shiny-basic-user-interface.html", "Chapter 2 Shiny - Basic User Interface ", " Chapter 2 Shiny - Basic User Interface "],["learning-objectives.html", "2.1 Learning objectives", " 2.1 Learning objectives The Shiny User Interface consists of 3 components Inputs Text, Numeric variables, Dates, Radio buttons/Check boxes, File uploads, Buttons Outputs Text, Tables, Plots, Downloads Layout functions Pages with sidebar(s) &amp; mainPanel(s), Bootstrap, Tabsets, Themes, CSS grid "],["fyi.html", "2.2 FYI", " 2.2 FYI Mastering Shiny online book: https://mastering-shiny.org Mastering Shiny Github-repo: https://github.com/hadley/mastering-shiny By using Github, YOU can contribute too. R4DS book club Github-repo: https://github.com/r4ds/bookclub-mshiny Shiny Cheat Sheet https://shiny.rstudio.com/articles/cheatsheet.html "],["the-shiny-basic-user-interfaceui.html", "2.3 The Shiny Basic User Interface(ui)", " 2.3 The Shiny Basic User Interface(ui) Recall, the simplest Shiny application has 2 components, ui &amp; server user interface contains nested R functions that assist in assembling the HTML. library(shiny) user_interface &lt;- fluidPage( **inputId** ) ## WE&#39;LL FOCUS HERE FIRST server &lt;- function(input, output, session) { } ## FOCUS HERE SECONDARILY shinyApp(ui = user_interface, server = server) Naming; inputId has 2 constraints inputId contain Only Letters, Numbers, and Underscores NO / -.!@#$%^&amp;*;: NO slashes, dashes, Nor special characters, inputID must be unique. "],["what-can-one-input.html", "2.4 What Can One INPUT?", " 2.4 What Can One INPUT? Text strings Numeric variables Dates Limited choices; Radio buttons/Check boxes/Select-dropdown menus File uploads Action buttons ## General Command Form #---------------------- Input-Command(inputId = &quot;string1&quot;, ## Don&#39;t forget tab completion &amp; F1. label = &quot;string2&quot;, ### Situation Dependent Variables ### value = # Initial value min = 0, max = 100, width = &#39;400px&#39;, height = &#39;100%&#39;, cols = 2, rows = 5, # Number of cols or rows to display placeholder = &quot;A word giving the user a hint&quot;, resize # Resize to fill/contract span ) "],["input-1-text-numeric.html", "2.5 Input 1 - Text &amp; Numeric", " 2.5 Input 1 - Text &amp; Numeric Every output (in the UI) is coupled with a render (in the server). ui &lt;- fluidPage( ## Text Input ## textInput(inputId = &quot;f_name&quot;, label = &quot;First name?&quot;), textInput(inputId = &quot;name&quot;, placeholder = &quot;What&#39;s your name?&quot;), passwordInput(inputId = &quot;password&quot;, label = &quot;What&#39;s your password?&quot;), textAreaInput(inputId = &quot;story&quot;, label = &quot;Tell me about yourself&quot;, rows = 3) ## Numeric inputs ## numericInput(inputId = &quot;x&quot;, label = &quot;Dependent Variable&quot;, value = 10), sliderInput(inputID = &quot;y_range&quot;, label = &quot;Range of Y:&quot;, value = c(10, 20), min = 0, max = 100) ) But wait there’s more! "],["inputs-2-dates-limited-choices-file-uploads-action-buttons.html", "2.6 Inputs 2 - Dates, Limited choices, File uploads, Action buttons", " 2.6 Inputs 2 - Dates, Limited choices, File uploads, Action buttons ui &lt;- fluidPage( # DATES dateInput(&quot;dob&quot;, &quot;When were you born?&quot;), dateRangeInput(&quot;holiday&quot;, &quot;Give start and end of Holiday season?&quot;), # LIMITED CHOICES animals &lt;- c(&quot;cat&quot;, &quot;dog&quot;, &quot;porpoise&quot;) ## Placed above UI radioButtons(&quot;animal&quot;, &quot;What&#39;s your favourite animal?&quot;, animals) state_name &lt;- c(&quot;AL&quot;, &quot;AK&quot;, ..., &quot;WY&quot;) ## Placed above UI selectInput(&quot;state&quot;, &quot;What&#39;s your favourite state?&quot;, state_name), # FILE UPLOADS fileInput(&quot;upload&quot;, NULL) # ACTION BUTTONS actionButton(&quot;click&quot;, &quot;Click me!&quot;), actionButton(&quot;calc_boolean&quot;, &quot;Calculate!&quot;, icon = icon(&quot;computer&quot;)) ) "],["what-can-one-output.html", "2.7 What can one OUTPUT?", " 2.7 What can one OUTPUT? Text Tables Plots Downloads Text Every output (in the UI) is coupled with a render (in the server). Note that there are two render functions which behave slightly differently: renderText() &lt;-&gt; textOutput() renderPrint() &lt;-&gt; verbatimTextOutput() ## User Interface #---------------- ui &lt;- fluidPage( # Static TEXT textOutput(&quot;Hello Friend&quot;), verbatimTextOutput(&quot;SSN&quot;) ) ## Server Section #---------------- server &lt;- function(input, output, session) { # Varible TEXT output$text &lt;- renderText( animals ), output$code &lt;- renderPrint({ ## Curly brackets needed IF state_name ## commands require multiple lines, print(&quot;OK&quot;) }), } "],["outputs-2-tables.html", "2.8 Outputs 2 - Tables", " 2.8 Outputs 2 - Tables NOTE: There are two options for displaying data frames in tables: tableOutput() &lt;-&gt; renderTable() for static tables, dataTableOutput() &lt;-&gt; renderDataTable() for dynamic tables # In UI section tableOutput(df_static), dataTableOutput(df_dynamic), # In SERVER section renderTable(df_static) renderDataTable(df_dynamic) "],["outputs-3-plots-downloads.html", "2.9 Outputs 3 - Plots, Downloads", " 2.9 Outputs 3 - Plots, Downloads plotOutput() &lt;-&gt; renderPlot() # PLOTS # In UI section plotOutput(&quot;plot&quot;, width = &quot;400px&quot;) # In SERVER section output$plot &lt;- renderPlot(plot(1:5), res = 96), # DOWNLOADS # downloadButton(&quot;downloadData&quot;, &quot;Download&quot;) # Download button; # requires new techniques in the server function, # so we’ll come back to that in Chapter 9. "],["layouts.html", "2.10 Layouts", " 2.10 Layouts Consider Using: 1. Bootstrap, 2. Page(s) with sidebar(s) &amp; mainPanel(s) 3. CSS Grid (12 columns) 4. Tabsets 5. Themes Example of Sidepanel and Mainpanel fluidPage( titlePanel(&quot;Hello Shiny!&quot;), sidebarLayout( sidebarPanel( ## sidebar sliderInput(&quot;obs&quot;, &quot;Observations:&quot;, min = 0, max = 1000, value = 500) ), mainPanel( ## mainPanel plotOutput(&quot;distPlot&quot;) ) ) ) "],["under-the-hood.html", "2.11 Under the hood", " 2.11 Under the hood Use HTML or CSS to get the job done! &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;form-group shiny-input-container&quot;&gt; &lt;label for=&quot;name&quot;&gt;What&#39;s your name?&lt;/label&gt; &lt;input id=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot; value=&quot;&quot;/&gt; &lt;/div&gt; &lt;/div&gt; "],["other-tools-material.html", "2.12 Other tools &amp; material", " 2.12 Other tools &amp; material awesome-shiny-extensions listing by Nan Xiao shinyWidgets shiny.semantic shinyMobile shinymaterial shinydashboard NOTE: Some tools may need devtools to install from GitHub repos. Books: Engineering Production-Grade Shiny Apps Outstanding User Interfaces with Shiny "],["summary.html", "2.13 Summary", " 2.13 Summary Chapter 3: Basic UI introduces the 3 components of user interface for Shiny Inputs; Text, Numeric variables, Dates, Limited choices, Radio buttons/Check boxes, File uploads, Buttons renderText() &lt;-&gt; textOutput() renderPrint() &lt;-&gt; verbatimTextOutput() Outputs; Text, Tables, Plots, Downloads tableOutput() &lt;-&gt; renderTable() for static tables dataTableOutput() &lt;-&gt; renderDataTable() for dynamic tables plotOutput() &lt;-&gt; renderPlot() Layout functions; Pages with sidebar(s) &amp; mainPanel(s), Bootstrap, Tabsets, Themes, CSS "],["thank-you.html", "2.14 Thank you", " 2.14 Thank you Questions, Utterances, Repartee &amp; Small Talk Contact: matt . curcio . ri @ gmail . com "],["basic-reactivity.html", "Chapter 3 Basic Reactivity ", " Chapter 3 Basic Reactivity "],["recap.html", "3.1 Recap", " 3.1 Recap Important Learnings so far, main app components: Front end - the ui object contains the HTML presented to every user of your app. is simple because every user gets the same HTML. Back end - the server object is more complicated because every user needs to get an independent version of the app (when user A modifies an input field, user B shouldn’t see their outputs change). creates a new environment for each run, giving each session to have a unique state. server &lt;- function(input, output, session) 1 input - list-like object - used for receiving input( sent from the browser) - read-only - must be read in a reactive context (e.g. renderText() or reactive()) 2 output - list-like object - used for sending output - ALWAYS use with a render fn() - sets up the reactive context &amp; renders the HTML. ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { output$greeting &lt;- renderText({ paste0(&quot;Hello &quot;, input$name, &quot;!&quot;) }) } "],["reactive-programming.html", "3.2 Reactive Programming", " 3.2 Reactive Programming Mental Model - tell vs inform (providing Shiny with recipes, not giving it commands). 3.2.1 Imperative vs declarative programming This difference between commands and recipes is one of the key differences between two important styles of programming: - Imperative programming - issue a specific command and it’s carried out immediately. - Declarative programming - express higher-level goals or describe important constraints, and rely on someone else to decide how and/or when to translate that into action. Imperative code is assertive; vs declarative code is passive-aggressive “Make me a sandwich” vs “Ensure there is a sandwich in the refrigerator whenever I look inside of it” In essesnce, you describe your overall goals, and the software figures out how to achieve them without further intervention. 3.2.2 Laziness It allows apps to be extremely lazy. A Shiny app will only ever do the minimal amount of work needed to update the output controls that you can currently see. CAUTION: If you’re working on a Shiny app and you just can’t figure out why your code never gets run, double check that your UI and server functions are using the same identifiers. 3.2.3 The reactive graph understanding order of execution code is only run when needed reactive graph - describes how inputs and outputs are connected - describe this relationship (output has a reactive dependency on input) mermaid(&quot; graph LR A[name] --- B&gt;greeting] &quot;) reactive graph is a powerful tool for understanding how your app works. - Make by hand - Use DiagrammeR pkg to make it manually yourself - Use reactlog pkg to do it automatically (more in later chapters) "],["reactive-expressions-1.html", "3.3 Reactive expressions", " 3.3 Reactive expressions What - A tool that reduces duplication in your reactive code by introducing additional nodes into the reactive graph How - using reactive() # Just for example server &lt;- function(input, output, session) { string &lt;- reactive(paste0(&quot;Hello &quot;, input$name, &quot;!&quot;)) output$greeting &lt;- renderText(string()) } In other words , makes app cleaner &amp; more efficient (by removing redundant codes &amp; recomputation). It also simplifies the reactive graph. Reactive expressions have a flavour of both inputs and outputs: Like inputs, you can use the results of a reactive expression in an output. Like outputs, reactive expressions depend on inputs and automatically know when they need updating. New vocab: producers to refer to reactive inputs and expressions, and consumers to refer to reactive expressions and outputs Execution order - determined solely by the reactive graph (and not the order of lines of code/layout in the server fn unlike normal R scripts) "],["controlling-timing-of-evaluation.html", "3.4 Controlling timing of evaluation", " 3.4 Controlling timing of evaluation Timed invalidation How - using reactiveTimer() On click How - using actionButton(), eventReactive() "],["observers.html", "3.5 Observers", " 3.5 Observers There are two important differences between observeEvent() and eventReactive(): You don’t/can’t assign the result of observeEvent() to a variable, so You can’t refer to it from other reactive consumers. "],["execises.html", "3.6 Execises", " 3.6 Execises mermaid(&quot; graph LR A(Rounded)--&gt;B[Rectangular] B--&gt;C{A Rhombus} C--&gt;D[Rectangle One] C--&gt;E[Rectangle Two] &quot;) mermaid(&quot; graph LR A[A arr_text] --- B&gt;A arrowtext] &quot;) "],["case-study-er-injuries.html", "Chapter 4 Case study: ER injuries", " Chapter 4 Case study: ER injuries Learning objectives: Learn how to create a more complex Shiny app Get an idea how to build your app based on your data exploration Learn how to create your app step-by-step Get more comfortable using the techniques you learned so far "],["introduction-1.html", "4.1 Introduction", " 4.1 Introduction This Chapter is about building a more complex app with the tools we learned in the previous chapters. We’re going to use the following packages: library(shiny) library(vroom) library(tidyverse) "],["the-data.html", "4.2 The data", " 4.2 The data We’re exploring data from the National Electronic Injury Surveillance System (NEISS), which covers accidents reported from a sample of hospitals in the US. For every accident / inured person we have date, age, sex, race, body part, diagnosis and location (Home, School, Street Or Highway etc.) as well as primary product associated with the injury and a brief story how the accident occured. Further we have a weight attribute for an estimation how may people the current case represents if the dataset was scaled to the entire US population. Code to download the data: dir.create(&quot;neiss&quot;) download &lt;- function(name) { url &lt;- &quot;https://github.com/hadley/mastering-shiny/raw/master/neiss/&quot; download.file(paste0(url, name), paste0(&quot;neiss/&quot;, name), quiet = TRUE) } download(&quot;injuries.tsv.gz&quot;) download(&quot;population.tsv&quot;) download(&quot;products.tsv&quot;) Main data: injuries &lt;- vroom(&quot;neiss/injuries.tsv.gz&quot;) injuries ## # A tibble: 255,064 x 10 ## trmt_date age sex race body_part diag location prod_code weight ## &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2017-01-01 71 male white Upper Tr… Contusi… Other Pub… 1807 77.7 ## 2 2017-01-01 16 male white Lower Arm Burns, … Home 676 77.7 ## 3 2017-01-01 58 male white Upper Tr… Contusi… Home 649 77.7 ## 4 2017-01-01 21 male white Lower Tr… Strain,… Home 4076 77.7 ## 5 2017-01-01 54 male white Head Inter O… Other Pub… 1807 77.7 ## 6 2017-01-01 21 male white Hand Fracture Home 1884 77.7 ## 7 2017-01-01 35 female not s… Lower Tr… Strain,… Home 1807 87.1 ## 8 2017-01-01 62 female not s… Lower Arm Lacerat… Home 4074 87.1 ## 9 2017-01-01 22 male not s… Knee Disloca… Home 4076 87.1 ## 10 2017-01-01 58 female not s… Lower Leg Fracture Home 1842 87.1 ## # … with 255,054 more rows, and 1 more variable: narrative &lt;chr&gt; Product names: products &lt;- vroom(&quot;neiss/products.tsv&quot;) products ## # A tibble: 38 x 2 ## prod_code title ## &lt;dbl&gt; &lt;chr&gt; ## 1 464 knives, not elsewhere classified ## 2 474 tableware and accessories ## 3 604 desks, chests, bureaus or buffets ## 4 611 bathtubs or showers ## 5 649 toilets ## 6 676 rugs or carpets, not specified ## 7 679 sofas, couches, davenports, divans or st ## 8 1141 containers, not specified ## 9 1200 sports or recreational activity, n.e.c. ## 10 1205 basketball (activity, apparel or equip.) ## # … with 28 more rows Population data: population &lt;- vroom(&quot;neiss/population.tsv&quot;) population ## # A tibble: 170 x 3 ## age sex population ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 0 female 1924145 ## 2 0 male 2015150 ## 3 1 female 1943534 ## 4 1 male 2031718 ## 5 2 female 1965150 ## 6 2 male 2056625 ## 7 3 female 1956281 ## 8 3 male 2050474 ## 9 4 female 1953782 ## 10 4 male 2042001 ## # … with 160 more rows "],["exploration.html", "4.3 Exploration", " 4.3 Exploration As motivation for the app we want to build, we’re going to explore the data. Let’s have a look at accidents related to toilets: # product code for toilets is 649 selected &lt;- injuries %&gt;% filter(prod_code == 649) nrow(selected) ## [1] 2993 We’re interested in how many accidents related to toilets we see for different locations, body parts and diagnosis. selected %&gt;% count(location, wt = weight, sort = TRUE) ## # A tibble: 6 x 2 ## location n ## &lt;chr&gt; &lt;dbl&gt; ## 1 Home 99603. ## 2 Other Public Property 18663. ## 3 Unknown 16267. ## 4 School 659. ## 5 Street Or Highway 16.2 ## 6 Sports Or Recreation Place 14.8 selected %&gt;% count(body_part, wt = weight, sort = TRUE) ## # A tibble: 24 x 2 ## body_part n ## &lt;chr&gt; &lt;dbl&gt; ## 1 Head 31370. ## 2 Lower Trunk 26855. ## 3 Face 13016. ## 4 Upper Trunk 12508. ## 5 Knee 6968. ## 6 N.S./Unk 6741. ## 7 Lower Leg 5087. ## 8 Shoulder 3590. ## 9 All Of Body 3438. ## 10 Ankle 3315. ## # … with 14 more rows selected %&gt;% count(diag, wt = weight, sort = TRUE) ## # A tibble: 20 x 2 ## diag n ## &lt;chr&gt; &lt;dbl&gt; ## 1 Other Or Not Stated 32897. ## 2 Contusion Or Abrasion 22493. ## 3 Inter Organ Injury 21525. ## 4 Fracture 21497. ## 5 Laceration 18734. ## 6 Strain, Sprain 7609. ## 7 Dislocation 2713. ## 8 Hematoma 2386. ## 9 Avulsion 1778. ## 10 Nerve Damage 1091. ## 11 Poisoning 928. ## 12 Concussion 822. ## 13 Dental Injury 199. ## 14 Hemorrhage 167. ## 15 Crushing 114. ## 16 Dermat Or Conj 84.2 ## 17 Burns, Not Spec 67.2 ## 18 Puncture 67.2 ## 19 Burns, Thermal 34.0 ## 20 Burns, Scald 17.0 Next we’ll we create a plot for the number of accidents for different age and sex: summary &lt;- selected %&gt;% count(age, sex, wt = weight) %&gt;% left_join(y = population, by = c(&quot;age&quot;, &quot;sex&quot;)) %&gt;% mutate(rate = n / population * 1e4) summary %&gt;% ggplot(mapping = aes(x = age, y = rate, color = sex)) + geom_line(na.rm = TRUE) + labs(y = &quot;Injuries per 10,000 people&quot;) The goal is to build an app, which outputs the tables and the plot for different products, which the user selects. "],["prototype.html", "4.4 Prototype", " 4.4 Prototype The first version of the app is a dashboard, where the user can choose a product and get the tables and the plot we have seen in the previous chapter. Code of the ui: ui &lt;- fluidPage( # choose product fluidRow( column( width = 6, selectInput(inputId = &quot;code&quot;, label = &quot;Product&quot;, choices = prod_codes) ) ), # display tables fluidRow( column(width = 4, tableOutput(outputId = &quot;diag&quot;)), column(width = 4, tableOutput(outputId = &quot;body_part&quot;)), column(width = 4, tableOutput(outputId = &quot;location&quot;)) ), # display plot fluidRow( column(width = 12, plotOutput(outputId = &quot;age_sex&quot;)) ) ) Code of the server: server &lt;- function(input, output, session) { # reactive for filtered data frame selected &lt;- reactive( injuries %&gt;% filter(prod_code == input$code) ) # render diagnosis table output$diag &lt;- renderTable( selected() %&gt;% count(diag, wt = weight, sort = TRUE) ) # render body part table output$body_part &lt;- renderTable( selected() %&gt;% count(body_part, wt = weight, sort = TRUE) ) # render location table output$location &lt;- renderTable( selected() %&gt;% count(location, wt = weight, sort = TRUE) ) # reactive for plot data summary &lt;- reactive( selected() %&gt;% count(age, sex, wt = weight) %&gt;% left_join(y = population, by = c(&quot;age&quot;, &quot;sex&quot;)) %&gt;% mutate(rate = n / population * 1e4) ) # render plot output$age_sex &lt;- renderPlot( expr = { summary() %&gt;% ggplot(mapping = aes(x = age, y = n, colour = sex)) + geom_line() + labs(y = &quot;Estimated number of injuries&quot;) }, res = 96 ) } Note: The reactive for plot data is only used once. You could also compute the dataframe when rendering the plot, but it is good practise to seperate computing and plotting. It’s easier to understand and generalise. This prototype is available at https://hadley.shinyapps.io/ms-prototype/. Now we’re going to improve the app step-by-step. "],["polish-tables.html", "4.5 Polish tables", " 4.5 Polish tables The prototype version of the app has very long tables. To make it a little clearer we only want to show the top 5 and lump together all other categories in every table. As an example the diagnosis table for all products would look like this: injuries %&gt;% mutate(diag = fct_lump(fct_infreq(diag), n = 5)) %&gt;% group_by(diag) %&gt;% summarise(n = as.integer(sum(weight))) ## # A tibble: 6 x 2 ## diag n ## &lt;fct&gt; &lt;int&gt; ## 1 Other Or Not Stated 1806436 ## 2 Fracture 1558961 ## 3 Laceration 1432407 ## 4 Strain, Sprain 1432556 ## 5 Contusion Or Abrasion 1451987 ## 6 Other 1929147 "],["rate-vs-count.html", "4.6 Rate vs count", " 4.6 Rate vs count Next step is to give the user the chance to plot the data relative to 10,000 People or in absolute numbers. The new ui looks like this: ui &lt;- fluidPage( fluidRow( column( width = 8, selectInput( inputId = &quot;code&quot;, label = &quot;Product&quot;, choices = prod_codes, width = &quot;100%&quot; ) ), column( width = 2, selectInput(inputId = &quot;y&quot;, label = &quot;Y axis&quot;, choices = c(&quot;rate&quot;, &quot;count&quot;)) ) ), fluidRow( column(width = 4, tableOutput(outputId = &quot;diag&quot;)), column(width = 4, tableOutput(outputId = &quot;body_part&quot;)), column(width = 4, tableOutput(outputId = &quot;location&quot;)) ), fluidRow( column(width = 12, plotOutput(outputId = &quot;age_sex&quot;)) ) ) And plot rendering changes to: server &lt;- function(input, output, session) { ... output$age_sex &lt;- renderPlot( expr = { if (input$y == &quot;count&quot;) { summary() %&gt;% ggplot(mapping = aes(x = age, y = n, colour = sex)) + geom_line() + labs(y = &quot;Estimated number of injuries&quot;) } else { summary() %&gt;% ggplot(mapping = aes(x = age, y = rate, colour = sex)) + geom_line(na.rm = TRUE) + labs(y = &quot;Injuries per 10,000 people&quot;) } }, res = 96 ) } "],["narrative.html", "4.7 Narrative", " 4.7 Narrative Now we want a button to sample an accident story related to the currently chosen product and display it. We add the following ui elements: ui &lt;- fluidPage( ... fluidRow( column( width = 2, actionButton(inputId = &quot;story&quot;, label = &quot;Tell me a story&quot;) ), column(width = 10, textOutput(outputId = &quot;narrative&quot;)) ) ) In the backend we need an eventReactive that triggers, when the button is clicked or the selected data changes: server &lt;- function(input, output, session) { ... narrative_sample &lt;- eventReactive( eventExpr = list(input$story, selected()), valueExpr = selected() %&gt;% pull(narrative) %&gt;% sample(1) ) output$narrative &lt;- renderText(narrative_sample()) } The resulting version of the app is available at https://hadley.shinyapps.io/ms-prototype/. "],["workflow.html", "Chapter 5 Workflow ", " Chapter 5 Workflow "],["why-workflow.html", "5.1 Why workflow?", " 5.1 Why workflow? “I think of workflow as one of my”secret\" powers: one of the reasons that I’ve been able to accomplish so much is that I devote time to analysing and improving my workflow. I highly encourage you to do the same!\"…..Hadley Wikham Workflow makes the process of writing Shiny apps more enjoyable, and helps your skills improve more quickly. "],["learning-objectives-1.html", "5.2 Learning objectives", " 5.2 Learning objectives The goal of this chapter is to help you improve three important Shiny workflows: Learn basic development cycle for creating apps,making changes, and quickly expirement with the results. Learn how to debug Shiny apps - Learn how to write **self-contained reprexes** "],["development-workflow.html", "5.3 Development workflow", " 5.3 Development workflow Why development workflow? Allows you to reduce the time between making a change and seeing the outcome The faster you can iterate, the faster you can experiment, and the faster you can become a better Shiny developer. Two main workflows to optimise here: creating apps (for first time), making changes and experimenting with the results faster (speeding up the iterative cycle). 5.3.1 Creating apps Type shinyapp in app.R and you will see prompt to insert snippet(Shift + Tab) If you are using RStudio, you can create Shiny Web Application project easily 5.3.2 Seeing your changes faster Avoid clicking “Run App” button Use keyboard shortcut: Cmd/Ctrl + Shift + Enter Turn auto reload on and run the app in the background as described here. gives faster workflow: write some code, Cmd/Ctrl + S to save the file and experiment interactively. disadvantage: harder to debug because the app is running in a separate process. 5.3.3 Controlling the view Run in Viewer Pane: opens the app in the viewer pane . for smaller apps Run External: opens the app in your usual web browser. useful for larger apps "],["debugging.html", "5.4 Debugging", " 5.4 Debugging something will go wrong definitely. it takes years of experience to write code that works the first time (So, we need a robust workflow for identifying and fixing mistakes) Specific focus to three debugging challenges to Shiny apps 5.4.1 Three dubugging Challenges(What goes wrong) You get an unexpected error (easiest case). Solution : You will get a traceback which allows you to figure out exactly where the error occurred The interactive debugger is a powerful assistant for this process. You don’t get any errors, Solution: use the interactive debugger, along with your investigative skills to track down the root cause. All the values are correct, but they’re not updated when you expect Most challenging problem because it’s unique to Shiny, so you can’t take advantage of your existing R debugging skills. 5.4.2 How to fix errors (using tracebacks) In R, every error is accompanied by a traceback, or call stack, which literally traces back through the sequence of calls that lead to the error The functions are printed in reverse order The traceback tool pinpoints the location of an error. Example of reading traceback f &lt;- function(x) g(x) g &lt;- function(x) h(x) h &lt;- function(x) 2 * 2 f(3) ## [1] 4 f &lt;- function(x) g(x) g &lt;- function(x) h(x) h &lt;- function(x) x * 2 f(&quot;a&quot;) This will generate an error below f(&quot;a&quot;) #&gt; Error in x * 2: non-numeric argument to binary operator The traceback is shown below: Top of the stack point to an error traceback() #&gt; 3: h(x) #&gt; 2: g(x) #&gt; 1: f(&quot;a&quot;) Flipping the traceback shows the better sequence(the top of the stack poins to an error location) shows sequence of calls that lead to the error — f() called g() called h() (which errors) 1: f(&quot;a&quot;) 2: g(x) 3: h(x) 5.4.2 Tracebacks in Shiny You can’t use traceback() in Shiny because you can’t run code while an app is running. Shiny automatically print the traceback for you. library(shiny) f &lt;- function(x) g(x) g &lt;- function(x) h(x) h &lt;- function(x) x * 2 ui &lt;- fluidPage( selectInput(&quot;n&quot;, &quot;N&quot;, 1:10), plotOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot({ n &lt;- f(input$n) plot(head(cars, n)) }, res = 96) } shinyApp(ui, server) We will see an error below Error in *: non-numeric argument to binary operator 169: g [app.R#4] 168: f [app.R#3] 167: renderPlot [app.R#13] 165: func 125: drawPlot 111: &lt;reactive:plotObj&gt; 95: drawReactive 82: renderFunc 81: output$plot 1: runApp We can also flip the error Error in *: non-numeric argument to binary operator 1: runApp 81: output$plot 82: renderFunc 95: drawReactive 111: &lt;reactive:plotObj&gt; 125: drawPlot 165: func 167: renderPlot [app.R#13] 168: f [app.R#3] 169: g [app.R#4] 5.4.3 Three part of Shiny error stack First: few calls start the app. Ignore anything before the first runApp(); this is just the setup code to get the app running. 1: runApp #Sometimes, you may see other things before runAPP ignore them #1: source #3: print.shiny.appobj #5: runApp Second: some internal Shiny code in charge of calling the reactive expression(output$plot is where the problem is) : 81: output$plot 82: renderFunc 95: drawReactive 111: &lt;reactive:plotObj&gt; 125: drawPlot 165: func Third: Code that you have written 167: renderPlot [app.R#13] 168: f [app.R#3] 169: g [app.R#4] 5.4.4 How to fix errors (using interactive debugger) You have identified the error using traceback and want to figure out what’s causing it, Use the interactive debugger to debugg your code Two ways to launch the debugger: Add a call to browser() in your source code if (input$value == &quot;a&quot;) { browser() } # Or maybe if (my_reactive() &lt; 0) { browser() } Add an RStudio breakpoint by clicking to the left of the line number "],["getting-help-using-reprex.html", "5.5 Getting help (using Reprex)", " 5.5 Getting help (using Reprex) If you cant debug the error, it is time to ask for help at Shiny Community by creating Reprex A reprex is just some R code that works when you copy and paste it into a R session on another computer Good reprex, makes it easy for others to help you debug your app Below is an example of Shiny reprex 5.5.1 How to make a reprex Create a single self-contained file that contains everything needed to run your code (e.g load all packages) Test it by restarting fresh R session and then running the code Potential problem is sharing your data Use buil-in datasets(mpg), create sample datasets and illustrate the problem, use subset of the data with dput() (mydata &lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))) ## x y ## 1 1 a ## 2 2 b ## 3 3 c ## 4 4 d ## 5 5 e dput(mydata) ## structure(list(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)), class = &quot;data.frame&quot;, row.names = c(NA, ## -5L)) Last resort is to provide complete app.R and the needed data files using Gihub or Zip files (if reading data from disk seems irreducible part of the problem) Make sure you use relative paths Format your code for to be easy read Use styler package if you adopt tidyverse style guide 5.5.2 Making a minimal reprex Trim out all the code that’s ok (make the life of a helper much easier) rather than forcing a potential helper to understand your entire app. This process often lead you to discover what the problem is, so you don’t have to wait for help from someone else! A good way to find error code is to remove sections of code from your application, piece by piece, until the problem goes away If removing a particular piece of code makes the problem stop, it’s likely that that code is related to the problem. 5.5.2.1 Example of Bad reprex all the needed packages are not loaded The code is not style, making it uneasy to help library(shiny) shinyApp( ui = fluidPage( uiOutput(&quot;interaction_slider&quot;), verbatimTextOutput(&quot;breaks&quot;) ), server = function(input, output, session) { df &lt;- data.frame (dateTime = c(&quot;2019-08-20 16:00:00&quot;, &quot;2019-08-20 16:00:01&quot;, &quot;2019-08-20 16:00:02&quot;, &quot;2019-08-20 16:00:03&quot;, &quot;2019-08-20 16:00:04&quot;, &quot;2019-08-20 16:00:05&quot;), var1 = c(9, 8, 11, 14, 16, 1), var2 = c(3, 4, 15, 12, 11, 19), var3 = c(2, 11, 9, 7, 14, 1) ) timeSeries &lt;- as.xts(df[,2:4],order.by=strptime(df[,1], format=&quot;%Y-%m-%d %H:%M:%S&quot;)) print (paste(min(time(timeSeries)),is.POSIXt(min(time(timeSeries))),sep=&#39; &#39;)) print (paste(max(time(timeSeries)),is.POSIXt(max(time(timeSeries))),sep=&#39; &#39;)) output$interaction_slider &lt;- renderUI({ sliderInput( &quot;slider&quot;, 5.5.2.2 Making the bad reprex better(minimal) loaded needd packages The code is style, making it easy to help library(xts) library(lubridate) library(shiny) ui &lt;- fluidPage( uiOutput(&quot;interaction_slider&quot;), verbatimTextOutput(&quot;breaks&quot;) ) server &lt;- function(input, output, session) { df &lt;- data.frame( dateTime = c( &quot;2019-08-20 16:00:00&quot;, &quot;2019-08-20 16:00:01&quot;, &quot;2019-08-20 16:00:02&quot;, &quot;2019-08-20 16:00:03&quot;, &quot;2019-08-20 16:00:04&quot;, &quot;2019-08-20 16:00:05&quot; ), var1 = c(9, 8, 11, 14, 16, 1), var2 = c(3, 4, 15, 12, 11, 19), var3 = c(2, 11, 9, 7, 14, 1) ) timeSeries &lt;- as.xts(df[, 2:4], order.by = strptime(df[, 1], format = &quot;%Y-%m-%d %H:%M:%S&quot;) ) print(paste(min(time(timeSeries)), is.POSIXt(min(time(timeSeries))), sep = &quot; &quot;)) print(paste(max(time(timeSeries)), is.POSIXt(max(time(timeSeries))), sep = &quot; &quot;)) output$interaction_slider &lt;- renderUI({ sliderInput( &quot;slider&quot;, &quot;Select Range:&quot;, min = min(time(timeSeries)), max = max(time(timeSeries)), value = c(min, max) ) }) brks &lt;- reactive({ req(input$slider) seq(input$slider[1], input$slider[2], length.out = 10) }) output$breaks &lt;- brks } shinyApp(ui, server) Remove part of the code that is independent with the error(e.g two lines starting with print(), timeSeres and df) new server calls reduced: datetime &lt;- Sys.time() + (86400 * 0:10) server &lt;- function(input, output, session) { output$interaction_slider &lt;- renderUI({ sliderInput( &quot;slider&quot;, &quot;Select Range:&quot;, min = min(datetime), max = max(datetime), value = c(min, max) ) }) brks &lt;- reactive({ req(input$slider) seq(input$slider[1], input$slider[2], length.out = 10) }) output$breaks &lt;- brks } Next, the example uses a relatively sophisticated Shiny technique where the UI is generated in the server function. But the renderUI() doesn’t use any reactive inputs, so it should work the UI. this leads to new UI that generate the error: ui &lt;- fluidPage( sliderInput(&quot;slider&quot;, &quot;Select Range:&quot;, min = min(datetime), max = max(datetime), value = c(min, max) ), verbatimTextOutput(&quot;breaks&quot;) ) #&gt; Error: Type mismatch for `min`, `max`, and `value`. #&gt; i All values must have same type: either numeric, Date, or POSIXt. looking at each of the inputs we’re feeding to min, max, and value to see where the problem is: min(datetime) #&gt; [1] &quot;2021-03-15 23:20:03 UTC&quot; max(datetime) #&gt; [1] &quot;2021-03-25 23:20:03 UTC&quot; c(min, max) #&gt; [[1]] #&gt; function (..., na.rm = FALSE) .Primitive(&quot;min&quot;) #&gt; #&gt; [[2]] #&gt; function (..., na.rm = FALSE) .Primitive(&quot;max&quot;) Now the problem is obvious: we haven’t assigned min and max variables ui &lt;- fluidPage( sliderInput(&quot;slider&quot;, &quot;Select Range:&quot;, min = min(datetime), max = max(datetime), value = range(datetime) ), verbatimTextOutput(&quot;breaks&quot;) ) "],["layout-themes-html.html", "Chapter 6 Layout, themes, HTML", " Chapter 6 Layout, themes, HTML library(bslib) library(htmltools) library(shiny) "],["disclaimer.html", "6.1 Disclaimer", " 6.1 Disclaimer “Mastering Shiny” is a moving target. Much of the content for “Layout, themes, HTML” chapter was originally part of the “Basic UI” chapter. Hence, these notes have greater emphasis on low-level web concerns (html / css / bootstrap) "],["learning-objectives-2.html", "6.2 Learning objectives", " 6.2 Learning objectives Creating raw html using R HTML elements: attributes, classes, content CSS for styling Bootstrap (and related) front end toolkits Shiny produces single-page applications … but multipage layouts are possible "],["resources.html", "6.3 Resources", " 6.3 Resources 6.3.1 Websites Awesome Shiny Extensions Shiny Application Layout Guide Mozilla Developer Network Intro to HTML CSS First Steps Website parsing figure 6.3.2 Books Outstanding User Interfaces … Especially Chapters 1, 5, 6, 7 6.3.3 Packages / Tools Bootstrap Sass R packages {htmltools} (for building raw html) {sass} (for building css using Sass rules; not mentioned in Wickham) {bslib} (handles working with bootstrap) {thematic} (matches plotting theme to app theme) {shiny.semantic} (formantic) {shinyMobile} (framework 7) {shinymaterial} (Material design) {shinydashboard} (for building dashboards) "],["under-the-hood-1.html", "6.4 Under the hood", " 6.4 Under the hood A typical web app: In the browser (front-end): .html file defines the content .css files define the style javascript handles interactivity On the server (back-end): Requests received from the client R performs computations based on those requests Sends responses to the client 6.4.1 HTML - Hypertext markup language To view the .html for an app Open an app in the browser or Rstudio “View source” / “Inspect” / Open “Developer Tools” Typical .html structure: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;!-- Metadata goes here (encodings, dependencies, author ...) --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;The page title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Content goes here!--&gt; &lt;h1&gt;My Printed Title&lt;/h1&gt; &lt;p&gt; A paragraph of text. &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 6.4.2 Writing HTML with shiny / htmltools How to write .html using just R code? The simplest shiny UI: ui &lt;- shiny::fluidPage() The .html body for that UI can be viewed directly: cat( as.character(ui) ) &lt;div class=&quot;container-fluid&quot;&gt;&lt;/div&gt; To also include the ‘head’ for the .html: cat( shiny:::renderPage(ui) ) &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;script type=&quot;application/shiny-singletons&quot;&gt;&lt;/script&gt; &lt;script type=&quot;application/html-dependencies&quot;&gt;jquery[3.5.1];shiny-css[1.6.0];shiny-javascript[1.6.0];bootstrap[3.4.1]&lt;/script&gt; &lt;script src=&quot;shared/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;shared/shiny.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script src=&quot;shared/shiny.min.js&quot;&gt;&lt;/script&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link href=&quot;shared/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;link href=&quot;shared/bootstrap/accessibility/css/bootstrap-accessibility.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script src=&quot;shared/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;shared/bootstrap/accessibility/js/bootstrap-accessibility.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container-fluid&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; script and link elements in the &lt;head&gt; = dependencies for the site Adding bare HTML to the shiny-produced HTML ui_with_raw_html &lt;- shiny::fluidPage( # some raw html htmltools::HTML(r&quot;( &lt;h1&gt;This is a heading&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;First bullet&lt;/li&gt; &lt;li&gt;Second bullet&lt;/li&gt; &lt;/ul&gt; )&quot; ), # a shiny text imput textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;) ) cat( as.character(ui_with_raw_html) ) &lt;div class=&quot;container-fluid&quot;&gt; &lt;h1&gt;This is a heading&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;First bullet&lt;/li&gt; &lt;li&gt;Second bullet&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;form-group shiny-input-container&quot;&gt; &lt;label class=&quot;control-label&quot; id=&quot;name-label&quot; for=&quot;name&quot;&gt;What&#39;s your name?&lt;/label&gt; &lt;input id=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot; value=&quot;&quot;/&gt; &lt;/div&gt; &lt;/div&gt; Using HTML helpers: ui_from_html_helpers &lt;- shiny::fluidPage( h1(&quot;This is a heading&quot;, class = &quot;my-class&quot;), tags$ul( tags$li(&quot;First bullet&quot;), tags$li(&quot;Second bullet&quot;) ), textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;) ) cat( as.character(ui_from_html_helpers) ) ## &lt;div class=&quot;container-fluid&quot;&gt; ## &lt;h1 class=&quot;my-class&quot;&gt;This is a heading&lt;/h1&gt; ## &lt;ul&gt; ## &lt;li&gt;First bullet&lt;/li&gt; ## &lt;li&gt;Second bullet&lt;/li&gt; ## &lt;/ul&gt; ## &lt;div class=&quot;form-group shiny-input-container&quot;&gt; ## &lt;label class=&quot;control-label&quot; id=&quot;name-label&quot; for=&quot;name&quot;&gt;What&#39;s your name?&lt;/label&gt; ## &lt;input id=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot; value=&quot;&quot;/&gt; ## &lt;/div&gt; ## &lt;/div&gt; 6.4.3 CSS - Cascading Style Sheets CSS isn’t covered in the chapter (but links provided) but underlies how bootstrap styles your shiny app Much more detail at MDN; and in Outstanding User Interfaces with Shiny How does the browser display a site / app? MDN Website parsing figure 6.4.4 Using CSS to style a shiny app A simple CSS file to set any text with “my-class” as class to red /* ./examples/06-layout_themes_html-css_example/www/style.css */ .my-class { color: red } Put static files (javascript / css) in the ./www subdirectory of your app Include your files using tags$link when defining the UI Note: the path in the link should be “style.css” not “www/style.css” # ./examples/06-layout_themes_html-css_example/app.R library(shiny) ui &lt;- shiny::fluidPage( tags$link(rel = &quot;stylesheet&quot;, type = &quot;text/css&quot;, href = &quot;style.css&quot;), h1(&quot;This is a heading&quot;, class = &quot;my-class&quot;), textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) You can write custom rules to style based on html element (p, h1, …), attributes IDs and on interactive things (eg, when the mouse hovers) "],["bootstrap-themes.html", "6.5 Bootstrap &amp; Themes", " 6.5 Bootstrap &amp; Themes Shiny uses the bootstrap toolkit for styling. Here’s the strapline for bootstrap: Quickly design and customize responsive mobile-first sites with Bootstrap, the world’s most popular front-end open source toolkit, featuring Sass variables and mixins, responsive grid system, extensive prebuilt components, and powerful JavaScript plugins. What does that mean? Responsive The page alters layout / appearance for different screen widths Sass variables and mixins These are tools that reduce the amount of repetition when writing CSS Prebuilt components You don’t have to write your own button, navbar, etc … classes from scratch Javascript plugins eg, for using dropdowns So bootstrap solves lots of challenges for us Use package {bslib} to work with bootstrap in R To modify themes: bslib::bs_theme( # colours in RGB bg = &quot;#202123&quot;, # background fg = &quot;#B8BCC2&quot;, # foreground primary = NULL, secondary = NULL, success = NULL, info = NULL, warning = NULL, danger = NULL, # fonts base_font = list(bslib::font_google(&quot;Pacifico&quot;, local = TRUE), &quot;sans-serif&quot;), code_font = NULL, heading_font = NULL # further options ... ) Or use bootswatch to pick a prebuilt theme: bslib::bs_theme(bootswatch = &quot;sandstone&quot;) Then use a theme in your UI definition: theme_dark &lt;- bslib::bs_theme( bootswatch = &quot;darkly&quot;, base_font = list(bslib::font_google(&quot;Pacifico&quot;, local = TRUE), &quot;sans-serif&quot;) ) ui_with_bs &lt;- fluidPage( theme = theme_dark ) cat( shiny:::renderPage(ui_with_bs) ) &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;script type=&quot;application/shiny-singletons&quot;&gt;&lt;/script&gt; &lt;script type=&quot;application/html-dependencies&quot;&gt;jquery[3.6.0];shiny-css[1.6.0];shiny-javascript[1.6.0];bootstrap[4.6.0];_Pacifico[0.4.0];bs3compat[0.2.5.1]&lt;/script&gt; &lt;script src=&quot;jquery-3.6.0/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;shared/shiny.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script src=&quot;shared/shiny.min.js&quot;&gt;&lt;/script&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt; &lt;link href=&quot;bootstrap-4.6.0/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script src=&quot;bootstrap-4.6.0/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;_Pacifico-0.4.0/font.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script src=&quot;bs3compat-0.2.5.1/tabs.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bs3compat-0.2.5.1/bs3compat.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container-fluid&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; "],["layouts-1.html", "6.6 Layouts", " 6.6 Layouts The Layouts section was moved from the Basic UI chapter with little change. Rather than go over them again, we’ll rewrite a simple (single-page layout) app into something more complicated (and style it while we’re at it) See ./examples/06-layout_themes_html-single_to_multipage_app/ 6.6.1 Single-page Layouts Page functions: fluidPage, fixedPage, fillPage Layout functions: sidebarLayout, fluidRow, column 6.6.2 Multi-page Layouts Page functions: navbarPage (or nest the following in fluidPage) Layout functions: tabsetPanel, tabPanel, navlistPanel, navbarMenu "],["case-study.html", "6.7 Case study", " 6.7 Case study This is one of the first shiny apps I wrote, it pulls data for a specific user from Stack Overflow, works out which “tags” they have received the most votes for, then plots those top tags in a word cloud. 6.7.1 The initial app (app-01.R) How might this app be improved? Code stackr eagerly obtains data from stack overflow (maybe it should wait til user has input a complete user ID) UX Visual style is boring (maybe it should look more like stack overflow?) Could we input user name, rather than ID? Could we show the user-name / image, so the user knows they’ve copied in the correct user ID Can we add some extra plots / tables and make a multipage layout # Plot a wordcloud to summarise the tags that a stack-overflow user tends to # answer/ask about library(shiny) library(wordcloud) library(stackr) # Helper functions make_word_cloud &lt;- function(df) { with( df, wordcloud::wordcloud( words = tag_name, freq = answer_score, min.freq = 0, colors = RColorBrewer::brewer.pal(6, &quot;Purples&quot;)[-1], scale = c(10, 0.5) ) ) } # Define UI for application that plots information about a user&#39;s stack # overflow presence ui &lt;- fluidPage( # Application title titlePanel(&quot;Stack Overflow: User Statistics&quot;), # Sidebar for selecting which Stack Overflow user&#39;s data is presented sidebarLayout( sidebarPanel( textInput(&quot;user_id&quot;, &quot;Select a Stack Overflow user ID:&quot;, &quot;1845650&quot;) ), # Show a plot of a wordcloud of the user&#39;s answer-tags mainPanel( plotOutput(&quot;word_cloud&quot;) ) ) ) # Define server logic required to obtain data from stack-overflow and draw a # wordcloud server &lt;- function(input, output) { stack_data &lt;- reactive( stackr::stack_users(input[[&quot;user_id&quot;]], &quot;top-tags&quot;), ) output$word_cloud &lt;- renderPlot( make_word_cloud(stack_data()) ) } # Run the application shinyApp(ui = ui, server = server) 6.7.2 The final app (app.R) Relative to the original app, we have: introduced a new results table (containing the data obtained from stack-overflow) converted from a single-panel to a multi-panel layout (using tabsetPanel and two tabPanels) attempted to use the stack-overflow colour scheme as part of the apps theme, and also in the wordcloud colour scheme The stack overflow colour scheme was obtained by using the browser’s developer tools (here using “Inspect” in chromium and looking at the “styles” section) on an open SO page. # Plot a wordcloud to summarise the tags that a stack-overflow user tends to # answer/ask about library(shiny) library(wordcloud) library(stackr) # Helper functions make_word_cloud &lt;- function(df) { with( df, wordcloud::wordcloud( words = tag_name, freq = answer_score, min.freq = 0, colors = RColorBrewer::brewer.pal(6, &quot;Purples&quot;)[-1], scale = c(10, 0.5) ) ) } # Define UI for application that plots information about a user&#39;s stack # overflow presence ui &lt;- fluidPage( # Application title titlePanel(&quot;Stack Overflow: User Statistics&quot;), # Sidebar for selecting which Stack Overflow user&#39;s data is presented sidebarLayout( sidebarPanel( textInput(&quot;user_id&quot;, &quot;Select a Stack Overflow user ID:&quot;, &quot;1845650&quot;) ), # Show a plot of a wordcloud of the user&#39;s answer-tags mainPanel( plotOutput(&quot;word_cloud&quot;) ) ) ) # Define server logic required to obtain data from stack-overflow and draw a # wordcloud server &lt;- function(input, output) { stack_data &lt;- reactive( stackr::stack_users(input[[&quot;user_id&quot;]], &quot;top-tags&quot;), ) output$word_cloud &lt;- renderPlot( make_word_cloud(stack_data()) ) } # Run the application shinyApp(ui = ui, server = server) "],["user-feedback.html", "Chapter 7 User Feedback", " Chapter 7 User Feedback Validation: informing user, if inputs are invalid Notification: sending general messages to user Progress bars: informing user about progress of time consuming operations Confirmation/undo: giving the user a choice and extra security, when performing dangerous operations "],["validation.html", "7.1 Validation", " 7.1 Validation 7.1.1 Validating input giving feedback with the shinyFeedback package UI: add useShinyFeedback() ui &lt;- fluidPage( shinyFeedback::useShinyFeedback(), numericInput(&quot;n&quot;, &quot;n&quot;, value = 10), textOutput(&quot;half&quot;) ) Server: use feedback(), feedbackWarning(), feedbackDanger(), and feedbackSuccess() –&gt; example app 7.1.2 Cancelling execution with req() req() checks for required values before allowing a reactive producer to continue. Without req() the complete reactive graph is computed (even without user input): ui &lt;- fluidPage( selectInput(&quot;language&quot;, &quot;Language&quot;, choices = c(&quot;&quot;, &quot;English&quot;, &quot;Maori&quot;)), textInput(&quot;name&quot;, &quot;Name&quot;), textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { greetings &lt;- c( English = &quot;Hello&quot;, Maori = &quot;Ki ora&quot; ) output$greeting &lt;- renderText({ paste0(greetings[[input$language]], &quot; &quot;, input$name, &quot;!&quot;) }) } Using req(): server &lt;- function(input, output, session) { greetings &lt;- c( English = &quot;Hello&quot;, Maori = &quot;Ki ora&quot; ) output$greeting &lt;- renderText({ req(input$language, input$name) paste0(greetings[[input$language]], &quot; &quot;, input$name, &quot;!&quot;) }) } 7.1.3 req() and validation ui &lt;- fluidPage( shinyFeedback::useShinyFeedback(), textInput(&quot;dataset&quot;, &quot;Dataset name&quot;), tableOutput(&quot;data&quot;) ) server &lt;- function(input, output, session) { data &lt;- reactive({ req(input$dataset) exists &lt;- exists(input$dataset, &quot;package:datasets&quot;) shinyFeedback::feedbackDanger(&quot;dataset&quot;, !exists, &quot;Unknown dataset&quot;) req(exists, cancelOutput = TRUE) get(input$dataset, &quot;package:datasets&quot;) }) output$data &lt;- renderTable({ head(data()) }) } Check out this app: https://hadley.shinyapps.io/ms-require-cancel/ 7.1.4 Validate output validate(message) stops execution of the rest of the code and instead displays message in any downstream outputs ui &lt;- fluidPage( numericInput(&quot;x&quot;, &quot;x&quot;, value = 0), selectInput(&quot;trans&quot;, &quot;transformation&quot;, choices = c(&quot;square&quot;, &quot;log&quot;, &quot;square-root&quot;) ), textOutput(&quot;out&quot;) ) server &lt;- function(input, output, session) { output$out &lt;- renderText({ if (input$x &lt; 0 &amp;&amp; input$trans %in% c(&quot;log&quot;, &quot;square-root&quot;)) { validate(message = &quot;x can not be negative for this transformation&quot;) } switch(input$trans, square = input$x ^ 2, &quot;square-root&quot; = sqrt(input$x), log = log(input$x) ) }) } "],["notifications.html", "7.2 Notifications", " 7.2 Notifications Use showNotification(), if there is no problem, but you want the user to know what is happening. show a transient notification that automatically disappears after a fixed amount of time show a notification when a process starts and remove it when the process ends update a single notification with progressive updates 7.2.1 Transient notifications ui &lt;- fluidPage( actionButton(&quot;goodnight&quot;, &quot;Good night&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$goodnight, { showNotification(&quot;So long&quot;) Sys.sleep(1) showNotification(&quot;Farewell&quot;) Sys.sleep(1) showNotification(&quot;Auf Wiedersehen&quot;) Sys.sleep(1) showNotification(&quot;Adieu&quot;) }) } –&gt; example app 7.2.2 Removing on completion Show the notification when the task starts, and remove the notification when the task completes. Set duration = NULL and closeButton = FALSE so that the notification stays visible until the task is complete Store the id returned by showNotification(), and then pass this value to removeNotification() (&amp; on.exit()) server &lt;- function(input, output, session) { data &lt;- reactive({ id &lt;- showNotification(&quot;Reading data...&quot;, duration = NULL, closeButton = FALSE) on.exit(removeNotification(id), add = TRUE) read.csv(input$file$datapath) }) } 7.2.3 Progressive updates multiple calls to showNotification() –&gt; multiple notifications capture id from first call, use it in subsequent calls ui &lt;- fluidPage( tableOutput(&quot;data&quot;) ) server &lt;- function(input, output, session) { notify &lt;- function(msg, id = NULL) { showNotification(msg, id = id, duration = NULL, closeButton = FALSE) } data &lt;- reactive({ id &lt;- notify(&quot;Reading data...&quot;) on.exit(removeNotification(id), add = TRUE) Sys.sleep(1) notify(&quot;Reticulating splines...&quot;, id = id) Sys.sleep(1) notify(&quot;Herding llamas...&quot;, id = id) Sys.sleep(1) notify(&quot;Orthogonalizing matrices...&quot;, id = id) Sys.sleep(1) mtcars }) output$data &lt;- renderTable(head(data())) } "],["progress-bars.html", "7.3 Progress bars", " 7.3 Progress bars good for long-running tasks you need to be able to divide the big task into a known number of small pieces that each take roughly the same amount of time 7.3.1 Shiny Use withProgress() and incProgress() ui &lt;- fluidPage( numericInput(&quot;steps&quot;, &quot;How many steps?&quot;, 10), actionButton(&quot;go&quot;, &quot;go&quot;), textOutput(&quot;result&quot;) ) server &lt;- function(input, output, session) { data &lt;- eventReactive(input$go, { withProgress(message = &quot;Computing random number&quot;, { for (i in seq_len(input$steps)) { Sys.sleep(0.5) incProgress(1 / input$steps) } runif(1) }) }) output$result &lt;- renderText(round(data(), 2)) } Check out this app: https://hadley.shinyapps.io/ms-progress 7.3.2 Waiter waiter package uses an R6 object ui &lt;- fluidPage( waiter::use_waitress(), numericInput(&quot;steps&quot;, &quot;How many steps?&quot;, 10), actionButton(&quot;go&quot;, &quot;go&quot;), textOutput(&quot;result&quot;) ) server &lt;- function(input, output, session) { data &lt;- eventReactive(input$go, { # Create a new progress bar waitress &lt;- waiter::Waitress$new(max = input$steps) # Automatically close it when done on.exit(waitress$close()) for (i in seq_len(input$steps)) { Sys.sleep(0.5) # increment one step waitress$inc(1) } runif(1) }) output$result &lt;- renderText(round(data(), 2)) } –&gt; example app 7.3.3 Spinners also use the waiter() package instead of Waitress –&gt; Waiter ui &lt;- fluidPage( waiter::use_waiter(), actionButton(&quot;go&quot;, &quot;go&quot;), textOutput(&quot;result&quot;) ) server &lt;- function(input, output, session) { data &lt;- eventReactive(input$go, { waiter &lt;- waiter::Waiter$new() waiter$show() on.exit(waiter$hide()) Sys.sleep(sample(5, 1)) runif(1) }) output$result &lt;- renderText(round(data(), 2)) } Check out this app: https://hadley.shinyapps.io/ms-spinner-1 You can use Waiter for specific outputs, which will make the code simpler: ui &lt;- fluidPage( waiter::use_waiter(), actionButton(&quot;go&quot;, &quot;go&quot;), plotOutput(&quot;plot&quot;), ) server &lt;- function(input, output, session) { data &lt;- eventReactive(input$go, { waiter::Waiter$new(id = &quot;plot&quot;)$show() Sys.sleep(3) data.frame(x = runif(50), y = runif(50)) }) output$plot &lt;- renderPlot(plot(data()), res = 96) } Check out this app: https://hadley.shinyapps.io/ms-spinner-2 –&gt; example app for more spinners "],["confirming-and-undoing.html", "7.4 Confirming and undoing", " 7.4 Confirming and undoing for potentially dangerous actions, like deleting things 7.4.1 Explicit confirmation create a dialog box with modalDialog() modal_confirm &lt;- modalDialog( &quot;Are you sure you want to continue?&quot;, title = &quot;Deleting files&quot;, footer = tagList( actionButton(&quot;cancel&quot;, &quot;Cancel&quot;), actionButton(&quot;ok&quot;, &quot;Delete&quot;, class = &quot;btn btn-danger&quot;) ) ) ui &lt;- fluidPage( actionButton(&quot;delete&quot;, &quot;Delete all files?&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$delete, { showModal(modal_confirm) }) observeEvent(input$ok, { showNotification(&quot;Files deleted&quot;) removeModal() }) observeEvent(input$cancel, { removeModal() }) } 7.4.2 Undoing an action More like waiting some time before acually performing the task and giving the user time to stop the action before it’s actually happening. –&gt; example app "],["uploads-and-downloads.html", "Chapter 8 Uploads and Downloads", " Chapter 8 Uploads and Downloads In this chapter we learn how to upload/download files to/from a Shiny application. The UI for both uploads and downloads is simple, with essentially one function for each operation. The server side is more complex. The upload and download functions for the server each have their own quirks. "],["uploads.html", "8.1 Uploads", " 8.1 Uploads 8.1.1 UI To upload a file use fileInput(id, label). Some other arguments are multiple - can multiple files be uploaded at once? accept - what file types are accepted? (character vector) file extension: .csv, .tsv, .rds MIME type: application/JSON, image/png one of: audio/*, video/*, image/* 8.1.2 Server In the server, we work with a data frame with a special structure. There are 4 columns: name - name of the file on user’s computer size - file size in bytes. Default 5 MB; adjust with shiny.maxRequestSize option. type - MIME type of the file datapath - file path on the server. Temporary. 8.1.3 Uploading data There are 2 things to note about uploading a data set. Use req(input$file) to make sure file is uploaded before code runs. Use accept argument to fileInput() to limit input types. browser doesn’t always enforce, so make sure to validate() Example of uploading a data set and validating file type (from book): ui &lt;- fluidPage( fileInput(&quot;file&quot;, NULL, accept = c(&quot;.csv&quot;, &quot;.tsv&quot;)), numericInput(&quot;n&quot;, &quot;Rows&quot;, value = 5, min = 1, step = 1), tableOutput(&quot;head&quot;) ) server &lt;- function(input, output, session) { data &lt;- reactive({ req(input$file) ext &lt;- tools::file_ext(input$file$name) switch(ext, csv = vroom::vroom(input$file$datapath, delim = &quot;,&quot;), tsv = vroom::vroom(input$file$datapath, delim = &quot;\\t&quot;), validate(&quot;Invalid file; Please upload a .csv or .tsv file&quot;) ) }) output$head &lt;- renderTable({ head(data(), input$n) }) } "],["downloads.html", "8.2 Downloads", " 8.2 Downloads 8.2.1 UI For file downloads, use downloadButton(id, label) or downloadLink(id, label). Customize the appearance with the class or icon arguments. 8.2.2 Server In the server, use downloadHandler(filename, content). There are only 2 arguments, both are functions. filename - no arguments. Returns file name as a string. content(file) - one argument (file). Path to save the file. output$download &lt;- downloadHandler( filename = function() { paste0(input$dataset, &quot;.csv&quot;) }, content = function(file) { write.csv(data(), file) } ) 8.2.3 Downloading reports We can allow the user to download a report based on their exploration of an application. parameterized R Markdown is a good way to do this potential parameters - filters, simulation parameters specify parameters in YAML header of R Markdown document key idea - call rmarkdown::render() from content argument of downloadHandler() Some tips &amp; tricks: .Rmd renders in working directory so copy file temporary directory before rendering. .Rmd renders in current R process so consider running in separate session with e.g. callr package. "],["dynamic-ui.html", "Chapter 9 Dynamic UI", " Chapter 9 Dynamic UI Learning objectives: Learn how to add dynamics to a Shiny app to be able to see interactive changes to potentially automate command functions for more complex visualizations. At the end of this chapter, you will be able to understand what is a dynamic user interface, and what are the functions to update, hide or make visible and render the changes made interactively from UI to the server output. Introduction 1 - Updating inputs 2 - Dynamic visibility 3 - Creating UI with code Conclusions "],["introduction-2.html", "9.1 Introduction", " 9.1 Introduction This chapter based on Dynamic UI is made to addressing the user interface by updating the server outcome. There are three main sections, all of them relating to automated functions, able to dynamically change the output passing through parallel commands between the UI and the Server. What is a dynamic user interface? How to create dynamic user interfaces? One way to do this is changing the UI using code run in the Server function, and by modifying inputs and outputs to see dynamic changes in the app. "],["updating-inputs.html", "9.2 Updating inputs", " 9.2 Updating inputs Three are the key techniques for creating dynamic user interface: 1 - update functions 2 - tabsetPanel() 3 - uiOutput() and renderUI() In this first part of the Dynamic UI chapter we will see how to pass from a basic structure to a more complicate one by adding dynamics to the output of the app, calling the “updating functions”. As we know the basic structure of a Shiny app is made of a UI (user interface) and a Server. The first example is the User Interface and Server basic structure for updating the app. ############################################ # ui &lt;- fluidPage( # [id]Input(), # actionButton() # ) ############################################# # server &lt;- function(input, output, session) { # observeEvent(input$... , { # update[id]Input(inputId = ... , ... = input$... ) # }) # ... # } 9.2.1 Update functions The Update function allows you to modify the control after it has been created with a series of [id]Input and update[id]Input, as shown below: # [id]Input() # textInput() # ui # update [....] Input() # updateTextInput() # server # numericInput() # update [....] Input() # updateNumericInput() #------------------------------------- # selectInput() # update [....] Input() # updateSelectInput() # sliderInput() # update [....] Input() # updateSliderInput() Hierarchical, Freezing and Circular references Other considerations need to be done when requesting the app to update following an interactive input request made by the user. For example, the selection of natural hierarchy in the data is one of them, and it is important to create a user interface that allows updating the input maintaining stability while dynamically generating changes across multiple categories. Further considerations involve establishing priorities with the application of key features such as freezing Reactive Inputs, a provided feature to freeze part of the inputs when expected a series of changes and so for establishing priorities and visually summarize data correctly. # [id]Input() # tableOutput() # observeEvent() # update[id]Input() The function update[id]Input() only affects all outputs and observers that have run, for this reason, the freezing function would let you hierarchically updating all your inputs before displaying it. # [id]Input() # [some]Output() # observeEvent() # freezeReactiveValue() “freezing” the input # update[id]Input() The last consideration for this section is to circularity as seen in many apps, it is created when requested for making simultaneous changes recursively. In other words, it is seen in apps when updating the input, automatically another input is created in the function of the first one. Under this condition, the cycle can create an recursive loop on the current value of the input bringing it to run again and again in circularity. How the “Action button” reset the input A simple example of the use of this command is the Reset button. It is one of the clearest examples of what is meant with making dynamic changes. When the user interactively intervenes on the app making a choice, then the “reset” button makes it easy to reset the parameters back to their initial value. # [id]Input() # actionButton() # observeEvent() # update[id]Input() # [id]Input() # actionButton() # observeEvent() # updateActionButton() A simple use of the reset input button is shown in this example: Spring temperature generally varies on average between 19 and 25 C° degrees, let’s set an average value of 21 C° as reset point. ui &lt;- fluidPage( sliderInput(&quot;temperature&quot;, &quot;Spring temperature&quot;, 21, min = 19, max = 25), actionButton(&quot;reset&quot;, &quot;Reset&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$reset,{ updateSliderInput(inputId = &quot;temperature&quot;, value = 21) }) } "],["dynamic-visibility.html", "9.3 Dynamic visibility", " 9.3 Dynamic visibility To show and hide parts of the UI dynamically and interactively. The tabsetPanel() is the second function for this chapter and it involves the visibility of part of the app. This second function is made to let the user show and/or hide some of the tabs set in the main panel. It is a technique that allows managing the appearance of the app with selecting visibility of the tabs as shown in the Tabsets section of the Shiny.rstudio.com guide’s page of the website. To enhance your app with features and the most wanted themes and as an example on how to set the visibility of a tab in your app, you can follow the steps found here: Gallery As an example here is shown how to switch between panels hiding one panel and showing the other with different content. library(shiny) ################## switcher ############################## ui &lt;- fluidPage( sidebarLayout( sidebarPanel( selectInput(&quot;controller&quot;, &quot;Show&quot;, choices = c(&quot;plot&quot;,&quot;summary&quot;)) ), mainPanel( tabsetPanel( id = &quot;switcher&quot;, type = &quot;hidden&quot;, tabPanelBody(&quot;plot&quot;, &quot;Plot&quot;), tabPanelBody(&quot;summary&quot;, &quot;Summary&quot;) ) ) ) ) server &lt;- function(input, output, session) { observeEvent(input$controller, { updateTabsetPanel(inputId = &quot;switcher&quot;, selected = input$controller) }) } Finally, the technique of the Conditional UI allows you to simulate different parameters to be set in the app. The tabsetPanel() is updated with input requests as a separate section with different types of [id]Input() and then embedded inside a fuller UI. Example of a chunk of code to be integrated in the UI: parameter_tabs &lt;- tabsetPanel( tabPanel(&quot;normal&quot;, numericInput(&quot;mean&quot;, &quot;mean&quot;, value = 1) ) ) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( numericInput(&quot;n&quot;, &quot;Number of samples&quot;, value = 100), parameter_tabs, # where to set the chunk of code ), mainPanel( plotOutput(&quot;hist&quot;) ) ) ) There are other options to use to be able to switch among different pages, an example of this is creating a wizard and using the switch_page() function, this will be shown in Chapter 18 - Functions as said in the book. "],["creating-ui-with-code.html", "9.4 Creating UI with code", " 9.4 Creating UI with code Create and modify the user interface while the app is running The last two functions uiOutput() and renderUI(), are for applying the technique of rendering the UI by setting the value of the new input to the current value of the existing control. This technique gives the developer the ability to create and modify the user interface while the app is running. uiOutput() act in the UI part of the app while renderUI() act in the Server. In this contest the function isolate() would be able to do this isolating a particular input, for more info see: Section 15.4.1 Final example to show the position of the two functions inside the UI and the Server: ############################################## ui &lt;- fluidPage( selectInput(&quot;type&quot;, &quot;type&quot;, c(&quot;slider&quot;, &quot;numeric&quot;)), uiOutput(&quot;numeric&quot;) ) ############################################### server &lt;- function(input, output, session) { output$numeric &lt;- renderUI({ if (input$type == &quot;slider&quot;) { sliderInput(&quot;n&quot;, &quot;n&quot;, value = 0, min = 0, max = 100) } else { numericInput(&quot;n&quot;, &quot;n&quot;, value = 0, min = 0, max = 100) } }) } #################################### In addition to the aforementioned functions more features are available as a composition of each other and many more, to allow the user for Multiple controls, Dynamic filtering and Dialog boxes. "],["conclusions.html", "9.5 Conclusions", " 9.5 Conclusions The dynamic of the UI can be appreciated by modification of the Server. Many compositions of the basic functions would let the user be able to interactively change the output to the desired visualization. "],["bookmarking.html", "Chapter 10 Bookmarking", " Chapter 10 Bookmarking In brief, bookmarking addresses the issue of not being able to expose the current state of the app in its URL. Because of this, your Shiny app cannot be bookmarked or share a specific place with others. Learning objectives: Learn how to add bookmarkButton() to the UI Learn how to make the ui into a function and understand why it is necessary Learn how to use enableBookmarking='url' to the shinyApp() call At the end of this chapter, you will be able to enable bookmarking for your app. Introduction 1 - Modifying app to be bookmarkable 2 - Breaking down generated URLs 3 - Updating the URL/Storing a richer state 4 - Bookmarking challenges "],["introduction-3.html", "10.1 Introduction", " 10.1 Introduction This chapter introduces the concept of bookmarking a Shiny app so that a user can conveniently return to a specific state of the app. As it it stands, Shiny apps are single-page application (SPA) - a web application or website that interacts with the user by dynamically rewriting the current web page with new data from the web server. This was one of the major drawbacks of employing Shiny apps. It is super inconvenient for you and your stakeholders to have to input the exact parameters in your application in order to produce the results you are trying to share. Now with bookmarking functionality, this problem is addressed. The rest of this chapter is going to illustrate concepts using the Shiny application proposed in Exercise #1, which displays the results of ambient::noise-simplex(). "],["modifying-app-to-be-bookmarkable.html", "10.2 Modifying app to be bookmarkable", " 10.2 Modifying app to be bookmarkable There are three main parts you must modify in a Shiny app in order for it to be bookmarkable: In the ui: make it a function In the ui: add the bookmarkButton() function In the shinyApp() call: include enableBookmarking = \"url\" ui &lt;- function(request) { fluidPage( sidebarLayout( sidebarPanel( sliderInput(&quot;omega&quot;, &quot;omega&quot;, value = 1, min = -2, max = 2, step = 0.01), sliderInput(&quot;delta&quot;, &quot;delta&quot;, value = 1, min = 0, max = 2, step = 0.01), sliderInput(&quot;damping&quot;, &quot;damping&quot;, value = 1, min = 0.9, max = 1, step = 0.001), numericInput(&quot;length&quot;, &quot;length&quot;, value = 100), bookmarkButton() ), mainPanel( plotOutput(&quot;fig&quot;) ) ) ) } shinyApp(ui, server, enableBookmarking = &quot;url&quot;) Making the ui a function Why? Because Shiny needs to be able to modify the input controls specified by the URL. Like arguments are passed within a normal R function as parameters to produce different outputs, the ui now needs to take in an argument (the URL) in order to return the app into a particular state. The URL holds information on the input parameters that needs to be changed, hence why the ui now needs to be a function. Adding the bookmarkButton() button to the app This function adds a button to the ui that captures the current values of all the input controls and generates a URL from it. More on this later. Adding enableBookmarking = \"url\" to the shinyApp() call This function ultimately puts the app together - the ui and the server. Adding this argument tells Shiny enable bookmarking and that the bookmark will be URL-encoded vs saved-on-server. More on this later "],["breaking-down-the-url.html", "10.3 Breaking down the URL", " 10.3 Breaking down the URL A default URL that is generated from within a Shiny app will look something like this: https://hadley.shinyapps.io/ms-bookmark-url/?_inputs_&amp;damping=0.966&amp;delta=1.25&amp;length=100&amp;omega=-0.54 OR http://127.0.0.1:4087/?_inputs_&amp;damping=0.997&amp;delta=1.37&amp;length=500&amp;omega=-0.9 But what do all these words and numbers mean? "],["updating-the-url.html", "10.4 Updating the URL", " 10.4 Updating the URL It is probably more convenient to have the URL just update itself whenever inputs change instead of having the user press button each time a state must be captured. This can be accomplished by wrapping information like input values and session information around an observer as such: observe({ reactiveValuesToList(input) session$doBookmark() }) The reactiveValuesToList(input) step does what you might expect as.list() to do in base R. It takes the reactive object, input and stores its values and dependencies in a list. The next step invokes the doBookmark() function from the session object. The session object is an environment that can be used to access information and functionality relating to the session. doBookmark() invokes the onBookmarked() callback function. FYI: a callback function is: a function that is passed as an argument to another function, to be “called back” at a later time. A function that accepts other functions as arguments is called a higher-order function, which contains the logic for when the callback function gets executed. 10.4.1 Storing a richer state URL bookmarking is simple and works everywhere you may want to deploy your Shiny app however, could become very long if you have a large number of inputs. If this is the case, it may be better to store your state on the server side. Shiny saves the state of your app in an .rds file on the server and generates a shorter and easier URL. To do this, you can simply change the enableBookmarking argument to be “server” instead of “url” shinyApp(ui, server, enableBookmarking = &quot;server&quot;) This generates URLs like this: http://127.0.0.1:4087/?_state_id_=0d645f1b28f05c97 The parameter in this instance is the state_id which corresponds to a directory in your working directory - shiny_bookmarks/0d645f1b28f05c97 ⚠️ Be sure to have a mechanism to routinely delete these directories. If your app requires bookmarking in a complex state and you do not delete these files, your app is going to take up more disk space and may start to lag. However, when you do delete these files, their corresponding URLs will also stop working. Just be sure to either send updated links to stakeholders or be mindful of the state of your app. "],["bookmarking-challenges.html", "10.5 Bookmarking Challenges", " 10.5 Bookmarking Challenges You must be extra cautious if your app relies on random number generation. Bookmarking will not generate the same results unless you make your process reproducible. Suggested solution: repeatable() : returns a wrapped version of a random data function that always uses the same seed when called. rnormA &lt;- repeatable(rnorm) Be sure to give your tabs an id when using tabsetPanel() Be cautious of what you share. If your app requires sensitive information, use setBookmarkExclude() somewhere in the server to ensure that they do not get included in your bookmark. setBookmarkExclude(c(\"secret1\", \"secret2\")) If you use reactiveValues() to manually manage our reactive state, use onBookmark() instead of onBookmarked(). This will be discussed more in Ch.16 and more details can be found in Advanced Bookmarking "],["why-reactivity.html", "Chapter 11 Why reactivity?", " Chapter 11 Why reactivity? This chapter starts a new section of the book focused on reactivity. Yes, we have already learned about reactivity in earlier chapters. But in this section, we shift from an intuitive understanding based on applying reactivity to a formal understanding of the underlying theory. This chapter focuses on what reactivity, or reactive programming, is and why it is used in Shiny. "],["introduction-4.html", "11.1 Introduction", " 11.1 Introduction Shiny is “magic” specifically, it is “good” magic Shiny magic = “simple concepts combined in consistent ways” (vs. heuristics and special cases) "],["why-do-we-need-reactive-programming.html", "11.2 Why do we need reactive programming?", " 11.2 Why do we need reactive programming? What is reactive programming? “focuses on values that change over time, and calculations and actions that depend on those values” (Wikipedia) \"… reactive programming is … concerned with data streams and the propagation of changes (emphasis mine). Why reactive programming in Shiny? Shiny applications are interactive need something dynamic, unlike most R code want inputs &amp; outputs to stay in sync, while minimizing computation outputs and reactive expressions change if and only if their inputs change reactive programming -&gt; automatic updating/propagation of necessary changes 11.2.1 Why can’t you use variables? reactive programming: values that change over time. don’t variables change over time? variables don’t update automatically -&gt; no good temp_c &lt;- 10 temp_f &lt;- (temp_c * 9 / 5) + 32 temp_f #&gt; [1] 50 temp_c &lt;- 30 # temp_f not automatically updated temp_f #&gt; [1] 50 11.2.2 Why about functions? solves automatic updating problem doesn’t solve necessary computation problem temp_c &lt;- 10 temp_f &lt;- function() { message(&quot;Converting&quot;) (temp_c * 9 / 5) + 32 } temp_f() #&gt; Converting #&gt; [1] 50 # temp_f automatically updated temp_c &lt;- -3 temp_f() #&gt; Converting #&gt; [1] 26.6 # but does unnecessary computation (recomputes every time it&#39;s called) temp_f() #&gt; Converting #&gt; [1] 26.6 11.2.3 Event-driven programming before, Shiny would probably have used event-driven programming callback functions that run in response to events Ex: when button clicked, run function to process order can implement with R6 classes in R DynamicValue &lt;- R6::R6Class(&quot;DynamicValue&quot;, list( value = NULL, on_update = NULL, get = function() self$value, set = function(value) { self$value &lt;- value if (!is.null(self$on_update)) self$on_update(value) invisible(self) }, onUpdate = function(on_update) { self$on_update &lt;- on_update invisible(self) } )) temp_c &lt;- DynamicValue$new() temp_c$onUpdate(function(value) { message(&quot;Converting&quot;) temp_f &lt;&lt;- (value * 9 / 5) + 32 }) temp_c$set(10) #&gt; Converting temp_f #&gt; [1] 50 temp_c$set(-3) #&gt; Converting temp_f #&gt; [1] 26.6 event-driven programming solves problem of unnecessary computation but introduces a new problem very carefully track which inputs affect which computations hard to balance correctness vs. performance "],["reactive-programming-1.html", "11.3 Reactive programming", " 11.3 Reactive programming Reactive programming combines features of solutions we’ve seen so far. library(shiny) reactiveConsole(TRUE) # let&#39;s us use reactivity in console temp_c &lt;- reactiveVal(10) # create temp_c() # get #&gt; [1] 10 temp_c(20) # set temp_c() # get #&gt; [1] 20 temp_f &lt;- reactive({ message(&quot;Converting&quot;) (temp_c() * 9 / 5) + 32 }) temp_f() #&gt; Converting #&gt; [1] 68 # temp_f automatically updates temp_c(-10) temp_f() #&gt; Converting #&gt; [1] 14 # _and_ only computes when needed (don&#39;t see &quot;Converting&quot;) temp_f() #&gt; [1] 14 2 important properties of reactive expressions lazy. only does work when it’s called cached. saves last result -&gt; only does work on first call "],["a-brief-history-of-reactive-programming.html", "11.4 A brief history of reactive programming", " 11.4 A brief history of reactive programming spreadsheets! (VisCalc, 1979) not really studied academically until late 1990s 2010s -&gt; mainstream JavaScript UI frameworks: Knockout, Ember, Meteor now: React, Vue, Angular “reactive programming” is a general term. a lot of variablility in implementations and terminology "],["the-reactive-graph-1.html", "Chapter 12 The reactive graph", " Chapter 12 The reactive graph This chapter gives an overview of the reactive graph and explains how reactive components are linked to each other. "],["quick-review-of-chapter-3-basic-reactivity.html", "12.1 Quick review of chapter 3 Basic reactivity", " 12.1 Quick review of chapter 3 Basic reactivity Imperative (most of R) vs declarative (shiny) Lazyness, only do what is necessary but could be difficult to debug The reactive graph notation: Execution order is not top to bottom but determined by the reactive graph Reactive expressions with reactive() Observers with observeEvent() "],["introduction-5.html", "12.2 Introduction", " 12.2 Introduction We begin with a simple example: ui &lt;- fluidPage( numericInput(&quot;a&quot;, &quot;a&quot;, value = 10), numericInput(&quot;b&quot;, &quot;b&quot;, value = 1), numericInput(&quot;c&quot;, &quot;c&quot;, value = 1), plotOutput(&quot;x&quot;), tableOutput(&quot;y&quot;), textOutput(&quot;z&quot;) ) server &lt;- function(input, output, session) { rng &lt;- reactive(input$a * 2) smp &lt;- reactive(sample(rng(), input$b, replace = TRUE)) bc &lt;- reactive(input$b * input$c) output$x &lt;- renderPlot(hist(smp())) output$y &lt;- renderTable(max(smp())) output$z &lt;- renderText(bc()) } "],["an-example.html", "12.3 An example", " 12.3 An example example from book example from reactlog "],["excercises.html", "12.4 Excercises", " 12.4 Excercises excercises in book Starting state is invalidated x1 = 1sec, x2 = 1sec, x3 = 2sec recursion "],["dynamism.html", "12.5 Dynamism", " 12.5 Dynamism ui &lt;- fluidPage( selectInput(&quot;choice&quot;, &quot;A or B?&quot;, c(&quot;a&quot;, &quot;b&quot;)), numericInput(&quot;a&quot;, &quot;a&quot;, 0), numericInput(&quot;b&quot;, &quot;b&quot;, 10), textOutput(&quot;out&quot;) ) server &lt;- function(input, output, session) { output$out &lt;- renderText({ # different reactive dependencies # a &lt;- input$a # b &lt;- input$b if (input$choice == &quot;a&quot;) { input$a } else { input$b } }) } "],["the-reactlog-package.html", "12.6 The reactlog package", " 12.6 The reactlog package reactlog::reactlog_enable() shiny::runApp(&quot;examples/14-the-reactive-graph/app.R&quot;) Ctrl+F3 or Cmd+F3 "],["summary-1.html", "12.7 Summary", " 12.7 Summary Key concepts that were covered in the chapter: How the reactive graph operates Invalidation cycle reactlog package "]]
