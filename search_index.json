[["index.html", "Mastering Shiny Book Club Welcome", " Mastering Shiny Book Club The R4DS Online Learning Community 2021-03-16 Welcome This is a companion for the book Mastering Shiny by Hadley Wickham. This companion is available at r4ds.io/mshiny. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book. This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["preface.html", "Chapter 1 Preface", " Chapter 1 Preface The preface chapter will not be studied as part of the book-club. It provides an overview of the purpose of shiny, a brief description of the main components of a shiny app and an introduction to reactive programming. All these ideas are studied in more detail in the later chapters (hence, why we’ve skipped it). There are some notes on setting up R/RStudio for developing shiny apps, on the packages that should be installed, and some pointers about deploying shiny apps. When shiny-apps are developed as part of the book-club, we will typically deploy them to the R4DS shinyapps.io account. shinyapps.io has a lot of detail on releasing shiny-apps to the world. If you have any questions / problems setting up shiny for local use, or with deployment of a shiny app to shinyapps.io, feel free to ask in either the “book_club-mastering_shiny” or the “help-4-shiny” channel on the R4DS slack. "],["your-first-shiny-app.html", "Chapter 2 Your first Shiny app", " Chapter 2 Your first Shiny app Learning objectives: Learn how to create a simple Shiny app Define the leanest version of an app you can build Review different ways to start and stop the app Identify the two key components of every Shiny app Understand how the two components are connected Observe how Shiny apps react to user input "],["introduction.html", "2.1 Introduction", " 2.1 Introduction This chapter is basically a quick demo of the minimum boilerplate needed for a Shiny app. It defines the two key components - the ui and the server Then introduces reactive programming - which is how shiny automatically updates outputs when inputs change. Shiny outputs (tables, charts etc.) can automatically react (recalculate) when their inputs change. 2.1.1 If you haven’t installed Shiny already: install.packages(&#39;shiny&#39;) Check you have version 1.5.0 or higher packageVersion(&quot;shiny&quot;) ## [1] &#39;1.6.0&#39; Load shiny library(&#39;shiny&#39;) "],["creating-an-app.html", "2.2 Creating an app", " 2.2 Creating an app Simplest way - create new directory for your app and add a single app.r file library(shiny) ui &lt;- fluidPage( &quot;Hello, world!&quot; ) server &lt;- function(input, output, session) { } shinyApp(ui, server) Looking closely at the code above, this app.r file does four things: Loads shiny Defines the ui - the HTML webpage humans interact with Specifies behaviour of the app in the server Executes shinyApp(ui, server) to construct and start the app "],["running-and-stopping-the-app.html", "2.3 Running and stopping the app", " 2.3 Running and stopping the app The basic workflow of shiny app development is… Write some code Start the app Play with the app Write some more code Repeat… 2.3.1 Running the app There are a few ways you can run your app If using R Studio: Click Run App button in document toolbar Keyboard shortcut is CMD / CTRL + SHIFT + ENTER If not using R Studio: (source()) the whole document or call shiny::runApp() The console message #&gt; Listening on http://127.0.0.1:3827 identifies your app in any (local) web browser. 127.0.0.1 is a standard address = this computer last 4 digits = randomly assigned port number Running a Shiny app keeps R busy and you will not be able to execute other commands in the console at that time. 2.3.2 Stopping the app: STOP sign on console toolbar ESC from within R console (CTRL + C is not in R Studio) Close shiny app window "],["adding-ui-controls.html", "2.4 Adding UI controls", " 2.4 Adding UI controls Replace the ui in your app with this code that shows you all the built-in data frames in the datasets package. ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, label = &quot;Dataset&quot;, choices = ls(&quot;package:datasets&quot;)), verbatimTextOutput(&quot;summary&quot;), tableOutput(&quot;table&quot;) ) Four new functions: fluidPage() - layout function to set up visual structure of page selectInput() - input control for user to interact with verbatimTextOutput() - output control - shows code result tableOutput - output control - displays tables These are all just ways to generate HTML Note: fluidPage() is just one option available for page setup. navBarPage() is a nice example for creating an app with page tabs. "],["adding-behaviour.html", "2.5 Adding behaviour", " 2.5 Adding behaviour Need server function to bring the outputs to life Reactive programming tells Shiny how to perform a function. This code tells shiny how to fill in the summary and table outputs we defined in the UI. server &lt;- function(input, output, session) { output$summary &lt;- renderPrint({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) summary(dataset) }) output$table &lt;- renderTable({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) dataset }) } Each output$out_id is a new shiny output to render where the UI defines it There are specific render functions render{Type} for different outputs: text tables plots images new ui components "],["reactive-expressions.html", "2.6 Reactive expressions", " 2.6 Reactive expressions Key part of reducing duplication and ensuring you D-R-Y Duplicated code is particularly bad for Shiny apps which can get cumbersome and more difficult to maintain and debug as they grow (Although the latest release of shiny does have some improved debugging tools) Reactive expressions combines some of the same logic as variables and functions, but is a bit different as these do not work the same in shiny as normal R programming. Create a reactive expression by wrapping a block of code in reactive({...}) and assigning it to a variable. You can use the reactive expression like a standard function with one important difference - it only runs once and caches the result until input changed. So once it is initialised it will return some form of constant until it’s updated again. The below code retrieves the dataset once, not twice server &lt;- function(input, output, session) { # Create a reactive expression dataset &lt;- reactive({ get(input$dataset, &quot;package:datasets&quot;) }) output$summary &lt;- renderPrint({ # Use a reactive expression by calling it like a function summary(dataset()) }) output$table &lt;- renderTable({ dataset() }) } "],["visualising-reactive-expressions.html", "2.7 Visualising reactive expressions", " 2.7 Visualising reactive expressions The flow visualised in 2.1 now has a middle layer - a reactive expression. Which lives in the server function of the app. The ui to server connections can be visualised like this: Using our ‘first app’ as an example: "],["shiny-resources.html", "2.8 Shiny resources", " 2.8 Shiny resources Shiny cheatsheet https://www.rstudio.com/resources/cheatsheets/ 2.8.1 Other resources Shiny Gallery has lots of inspiration and demos of specific ui components and server behaviours. https://shiny.rstudio.com/gallery/ Shiny Widgets Gallery is included in above link and introduces the main options for inputs in the ui. https://shiny.rstudio.com/gallery/widget-gallery.html Shiny Dashboard is a nice framework for creating good looking and well structured apps with minimal effort. May get limiting as you advance and want more customisation. https://rstudio.github.io/shinydashboard/index.html "],["meeting-videos.html", "2.9 Meeting Videos", " 2.9 Meeting Videos 2.9.1 Cohort 1 Meeting chat log "],["shiny-basic-user-interface.html", "Chapter 3 Shiny - Basic User Interface ", " Chapter 3 Shiny - Basic User Interface "],["learning-objectives.html", "3.1 Learning objectives", " 3.1 Learning objectives The Shiny User Interface consists of 3 components Inputs Text, Numeric variables, Dates, Radio buttons/Check boxes, File uploads, Buttons Outputs Text, Tables, Plots, Downloads Layout functions Pages with sidebar(s) &amp; mainPanel(s), Bootstrap, Tabsets, Themes, CSS grid "],["fyi.html", "3.2 FYI", " 3.2 FYI Mastering Shiny online book: https://mastering-shiny.org Mastering Shiny Github-repo: https://github.com/hadley/mastering-shiny By using Github, YOU can contribute too. R4DS book club Github-repo: https://github.com/r4ds/bookclub-mshiny Shiny Cheat Sheet https://shiny.rstudio.com/articles/cheatsheet.html "],["the-shiny-basic-user-interfaceui.html", "3.3 The Shiny Basic User Interface(ui)", " 3.3 The Shiny Basic User Interface(ui) Recall, the simplest Shiny application has 2 components, ui &amp; server user interface contains nested R functions that assist in assembling the HTML. library(shiny) user_interface &lt;- fluidPage( **inputId** ) ## WE&#39;LL FOCUS HERE FIRST server &lt;- function(input, output, session) { } ## FOCUS HERE SECONDARILY shinyApp(ui = user_interface, server = server) Naming; inputId has 2 constraints inputId contain Only Letters, Numbers, and Underscores NO / -.!@#$%^&amp;*;: NO slashes, dashes, Nor special characters, inputID must be unique. "],["what-can-one-input.html", "3.4 What Can One INPUT?", " 3.4 What Can One INPUT? Text strings Numeric variables Dates Limited choices; Radio buttons/Check boxes/Select-dropdown menus File uploads Action buttons ## General Command Form #---------------------- Input-Command(inputId = &quot;string1&quot;, ## Don&#39;t forget tab completion &amp; F1. label = &quot;string2&quot;, ### Situation Dependent Variables ### value = # Initial value min = 0, max = 100, width = &#39;400px&#39;, height = &#39;100%&#39;, cols = 2, rows = 5, # Number of cols or rows to display placeholder = &quot;A word giving the user a hint&quot;, resize # Resize to fill/contract span ) "],["input-1-text-numeric.html", "3.5 Input 1 - Text &amp; Numeric", " 3.5 Input 1 - Text &amp; Numeric Every output (in the UI) is coupled with a render (in the server). ui &lt;- fluidPage( ## Text Input ## textInput(inputId = &quot;f_name&quot;, label = &quot;First name?&quot;), textInput(inputId = &quot;name&quot;, placeholder = &quot;What&#39;s your name?&quot;), passwordInput(inputId = &quot;password&quot;, label = &quot;What&#39;s your password?&quot;), textAreaInput(inputId = &quot;story&quot;, label = &quot;Tell me about yourself&quot;, rows = 3) ## Numeric inputs ## numericInput(inputId = &quot;x&quot;, label = &quot;Dependent Variable&quot;, value = 10), sliderInput(inputID = &quot;y_range&quot;, label = &quot;Range of Y:&quot;, value = c(10, 20), min = 0, max = 100) ) But wait there’s more! "],["inputs-2-dates-limited-choices-file-uploads-action-buttons.html", "3.6 Inputs 2 - Dates, Limited choices, File uploads, Action buttons", " 3.6 Inputs 2 - Dates, Limited choices, File uploads, Action buttons ui &lt;- fluidPage( # DATES dateInput(&quot;dob&quot;, &quot;When were you born?&quot;), dateRangeInput(&quot;holiday&quot;, &quot;Give start and end of Holiday season?&quot;), # LIMITED CHOICES animals &lt;- c(&quot;cat&quot;, &quot;dog&quot;, &quot;porpoise&quot;) ## Placed above UI radioButtons(&quot;animal&quot;, &quot;What&#39;s your favourite animal?&quot;, animals) state_name &lt;- c(&quot;AL&quot;, &quot;AK&quot;, ..., &quot;WY&quot;) ## Placed above UI selectInput(&quot;state&quot;, &quot;What&#39;s your favourite state?&quot;, state_name), # FILE UPLOADS fileInput(&quot;upload&quot;, NULL) # ACTION BUTTONS actionButton(&quot;click&quot;, &quot;Click me!&quot;), actionButton(&quot;calc_boolean&quot;, &quot;Calculate!&quot;, icon = icon(&quot;computer&quot;)) ) "],["what-can-one-output.html", "3.7 What can one OUTPUT?", " 3.7 What can one OUTPUT? Text Tables Plots Downloads Text Every output (in the UI) is coupled with a render (in the server). Note that there are two render functions which behave slightly differently: renderText() &lt;-&gt; textOutput() renderPrint() &lt;-&gt; verbatimTextOutput() ## User Interface #---------------- ui &lt;- fluidPage( # Static TEXT textOutput(&quot;Hello Friend&quot;), verbatimTextOutput(&quot;SSN&quot;) ) ## Server Section #---------------- server &lt;- function(input, output, session) { # Varible TEXT output$text &lt;- renderText( animals ), output$code &lt;- renderPrint({ ## Curly brackets needed IF state_name ## commands require multiple lines, print(&quot;OK&quot;) }), } "],["outputs-2-tables.html", "3.8 Outputs 2 - Tables", " 3.8 Outputs 2 - Tables NOTE: There are two options for displaying data frames in tables: tableOutput() &lt;-&gt; renderTable() for static tables, dataTableOutput() &lt;-&gt; renderDataTable() for dynamic tables # In UI section tableOutput(df_static), dataTableOutput(df_dynamic), # In SERVER section renderTable(df_static) renderDataTable(df_dynamic) "],["outputs-3-plots-downloads.html", "3.9 Outputs 3 - Plots, Downloads", " 3.9 Outputs 3 - Plots, Downloads plotOutput() &lt;-&gt; renderPlot() # PLOTS # In UI section plotOutput(&quot;plot&quot;, width = &quot;400px&quot;) # In SERVER section output$plot &lt;- renderPlot(plot(1:5), res = 96), # DOWNLOADS # downloadButton(&quot;downloadData&quot;, &quot;Download&quot;) # Download button; # requires new techniques in the server function, # so we’ll come back to that in Chapter 9. "],["layouts.html", "3.10 Layouts", " 3.10 Layouts Consider Using: 1. Bootstrap, 2. Page(s) with sidebar(s) &amp; mainPanel(s) 3. CSS Grid (12 columns) 4. Tabsets 5. Themes Example of Sidepanel and Mainpanel fluidPage( titlePanel(&quot;Hello Shiny!&quot;), sidebarLayout( sidebarPanel( ## sidebar sliderInput(&quot;obs&quot;, &quot;Observations:&quot;, min = 0, max = 1000, value = 500) ), mainPanel( ## mainPanel plotOutput(&quot;distPlot&quot;) ) ) ) "],["under-the-hood.html", "3.11 Under the hood", " 3.11 Under the hood Use HTML or CSS to get the job done! &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;form-group shiny-input-container&quot;&gt; &lt;label for=&quot;name&quot;&gt;What&#39;s your name?&lt;/label&gt; &lt;input id=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot; value=&quot;&quot;/&gt; &lt;/div&gt; &lt;/div&gt; "],["other-tools-material.html", "3.12 Other tools &amp; material", " 3.12 Other tools &amp; material awesome-shiny-extensions listing by Nan Xiao shinyWidgets shiny.semantic shinyMobile shinymaterial shinydashboard NOTE: Some tools may need devtools to install from GitHub repos. Books: Engineering Production-Grade Shiny Apps Outstanding User Interfaces with Shiny "],["summary.html", "3.13 Summary", " 3.13 Summary Chapter 3: Basic UI introduces the 3 components of user interface for Shiny Inputs; Text, Numeric variables, Dates, Limited choices, Radio buttons/Check boxes, File uploads, Buttons renderText() &lt;-&gt; textOutput() renderPrint() &lt;-&gt; verbatimTextOutput() Outputs; Text, Tables, Plots, Downloads tableOutput() &lt;-&gt; renderTable() for static tables dataTableOutput() &lt;-&gt; renderDataTable() for dynamic tables plotOutput() &lt;-&gt; renderPlot() Layout functions; Pages with sidebar(s) &amp; mainPanel(s), Bootstrap, Tabsets, Themes, CSS "],["thank-you.html", "3.14 Thank you", " 3.14 Thank you Questions, Utterances, Repartee &amp; Small Talk Contact: matt . curcio . ri @ gmail . com "],["basic-reactivity.html", "Chapter 4 Basic Reactivity ", " Chapter 4 Basic Reactivity "],["recap.html", "4.1 Recap", " 4.1 Recap Important Learnings so far, main app components: Front end - the ui object contains the HTML presented to every user of your app. is simple because every user gets the same HTML. Back end - the server object is more complicated because every user needs to get an independent version of the app (when user A modifies an input field, user B shouldn’t see their outputs change). creates a new environment for each run, giving each session to have a unique state. server &lt;- function(input, output, session) 1 input - list-like object - used for receiving input( sent from the browser) - read-only - must be read in a reactive context (e.g. renderText() or reactive()) 2 output - list-like object - used for sending output - ALWAYS use with a render fn() - sets up the reactive context &amp; renders the HTML. ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { output$greeting &lt;- renderText({ paste0(&quot;Hello &quot;, input$name, &quot;!&quot;) }) } "],["reactive-programming.html", "4.2 Reactive Programming", " 4.2 Reactive Programming Mental Model - tell vs inform (providing Shiny with recipes, not giving it commands). 4.2.1 Imperative vs declarative programming This difference between commands and recipes is one of the key differences between two important styles of programming: - Imperative programming - issue a specific command and it’s carried out immediately. - Declarative programming - express higher-level goals or describe important constraints, and rely on someone else to decide how and/or when to translate that into action. Imperative code is assertive; vs declarative code is passive-aggressive “Make me a sandwich” vs “Ensure there is a sandwich in the refrigerator whenever I look inside of it” In essesnce, you describe your overall goals, and the software figures out how to achieve them without further intervention. 4.2.2 Laziness It allows apps to be extremely lazy. A Shiny app will only ever do the minimal amount of work needed to update the output controls that you can currently see. CAUTION: If you’re working on a Shiny app and you just can’t figure out why your code never gets run, double check that your UI and server functions are using the same identifiers. 4.2.3 The reactive graph understanding order of execution code is only run when needed reactive graph - describes how inputs and outputs are connected - describe this relationship (output has a reactive dependency on input) mermaid(&quot; graph LR A[name] --- B&gt;greeting] &quot;) reactive graph is a powerful tool for understanding how your app works. - Make by hand - Use DiagrammeR pkg to make it manually yourself - Use reactlog pkg to do it automatically (more in later chapters) "],["reactive-expressions-1.html", "4.3 Reactive expressions", " 4.3 Reactive expressions What - A tool that reduces duplication in your reactive code by introducing additional nodes into the reactive graph How - using reactive() # Just for example server &lt;- function(input, output, session) { string &lt;- reactive(paste0(&quot;Hello &quot;, input$name, &quot;!&quot;)) output$greeting &lt;- renderText(string()) } In other words , makes app cleaner &amp; more efficient (by removing redundant codes &amp; recomputation). It also simplifies the reactive graph. Reactive expressions have a flavour of both inputs and outputs: Like inputs, you can use the results of a reactive expression in an output. Like outputs, reactive expressions depend on inputs and automatically know when they need updating. New vocab: producers to refer to reactive inputs and expressions, and consumers to refer to reactive expressions and outputs Execution order - determined solely by the reactive graph (and not the order of lines of code/layout in the server fn unlike normal R scripts) "],["controlling-timing-of-evaluation.html", "4.4 Controlling timing of evaluation", " 4.4 Controlling timing of evaluation Timed invalidation How - using reactiveTimer() On click How - using actionButton(), eventReactive() "],["observers.html", "4.5 Observers", " 4.5 Observers There are two important differences between observeEvent() and eventReactive(): You don’t/can’t assign the result of observeEvent() to a variable, so You can’t refer to it from other reactive consumers. "],["execises.html", "4.6 Execises", " 4.6 Execises mermaid(&quot; graph LR A(Rounded)--&gt;B[Rectangular] B--&gt;C{A Rhombus} C--&gt;D[Rectangle One] C--&gt;E[Rectangle Two] &quot;) mermaid(&quot; graph LR A[A arr_text] --- B&gt;A arrowtext] &quot;) "],["case-study-er-injuries.html", "Chapter 5 Case study: ER injuries", " Chapter 5 Case study: ER injuries Learning objectives: Learn how to create a more complex Shiny app Get an idea how to build your app based on your data exploration Learn how to create your app step-by-step Get more comfortable using the techniques you learned so far "],["introduction-1.html", "5.1 Introduction", " 5.1 Introduction This Chapter is about building a more complex app with the tools we learned in the previous chapters. We’re going to use the following packages: library(shiny) library(vroom) library(tidyverse) "],["the-data.html", "5.2 The data", " 5.2 The data We’re exploring data from the National Electronic Injury Surveillance System (NEISS), which covers accidents reported from a sample of hospitals in the US. For every accident / inured person we have date, age, sex, race, body part, diagnosis and location (Home, School, Street Or Highway etc.) as well as primary product associated with the injury and a brief story how the accident occured. Further we have a weight attribute for an estimation how may people the current case represents if the dataset was scaled to the entire US population. Code to download the data: dir.create(&quot;neiss&quot;) download &lt;- function(name) { url &lt;- &quot;https://github.com/hadley/mastering-shiny/raw/master/neiss/&quot; download.file(paste0(url, name), paste0(&quot;neiss/&quot;, name), quiet = TRUE) } download(&quot;injuries.tsv.gz&quot;) download(&quot;population.tsv&quot;) download(&quot;products.tsv&quot;) Main data: injuries &lt;- vroom(&quot;neiss/injuries.tsv.gz&quot;) injuries ## # A tibble: 255,064 x 10 ## trmt_date age sex race body_part diag location prod_code weight ## &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2017-01-01 71 male white Upper Tr… Contusi… Other Pub… 1807 77.7 ## 2 2017-01-01 16 male white Lower Arm Burns, … Home 676 77.7 ## 3 2017-01-01 58 male white Upper Tr… Contusi… Home 649 77.7 ## 4 2017-01-01 21 male white Lower Tr… Strain,… Home 4076 77.7 ## 5 2017-01-01 54 male white Head Inter O… Other Pub… 1807 77.7 ## 6 2017-01-01 21 male white Hand Fracture Home 1884 77.7 ## 7 2017-01-01 35 female not s… Lower Tr… Strain,… Home 1807 87.1 ## 8 2017-01-01 62 female not s… Lower Arm Lacerat… Home 4074 87.1 ## 9 2017-01-01 22 male not s… Knee Disloca… Home 4076 87.1 ## 10 2017-01-01 58 female not s… Lower Leg Fracture Home 1842 87.1 ## # … with 255,054 more rows, and 1 more variable: narrative &lt;chr&gt; Product names: products &lt;- vroom(&quot;neiss/products.tsv&quot;) products ## # A tibble: 38 x 2 ## prod_code title ## &lt;dbl&gt; &lt;chr&gt; ## 1 464 knives, not elsewhere classified ## 2 474 tableware and accessories ## 3 604 desks, chests, bureaus or buffets ## 4 611 bathtubs or showers ## 5 649 toilets ## 6 676 rugs or carpets, not specified ## 7 679 sofas, couches, davenports, divans or st ## 8 1141 containers, not specified ## 9 1200 sports or recreational activity, n.e.c. ## 10 1205 basketball (activity, apparel or equip.) ## # … with 28 more rows Population data: population &lt;- vroom(&quot;neiss/population.tsv&quot;) population ## # A tibble: 170 x 3 ## age sex population ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 0 female 1924145 ## 2 0 male 2015150 ## 3 1 female 1943534 ## 4 1 male 2031718 ## 5 2 female 1965150 ## 6 2 male 2056625 ## 7 3 female 1956281 ## 8 3 male 2050474 ## 9 4 female 1953782 ## 10 4 male 2042001 ## # … with 160 more rows "],["exploration.html", "5.3 Exploration", " 5.3 Exploration As motivation for the app we want to build, we’re going to explore the data. Let’s have a look at accidents related to toilets: # product code for toilets is 649 selected &lt;- injuries %&gt;% filter(prod_code == 649) nrow(selected) ## [1] 2993 We’re interested in how many accidents related to toilets we see for different locations, body parts and diagnosis. selected %&gt;% count(location, wt = weight, sort = TRUE) ## # A tibble: 6 x 2 ## location n ## &lt;chr&gt; &lt;dbl&gt; ## 1 Home 99603. ## 2 Other Public Property 18663. ## 3 Unknown 16267. ## 4 School 659. ## 5 Street Or Highway 16.2 ## 6 Sports Or Recreation Place 14.8 selected %&gt;% count(body_part, wt = weight, sort = TRUE) ## # A tibble: 24 x 2 ## body_part n ## &lt;chr&gt; &lt;dbl&gt; ## 1 Head 31370. ## 2 Lower Trunk 26855. ## 3 Face 13016. ## 4 Upper Trunk 12508. ## 5 Knee 6968. ## 6 N.S./Unk 6741. ## 7 Lower Leg 5087. ## 8 Shoulder 3590. ## 9 All Of Body 3438. ## 10 Ankle 3315. ## # … with 14 more rows selected %&gt;% count(diag, wt = weight, sort = TRUE) ## # A tibble: 20 x 2 ## diag n ## &lt;chr&gt; &lt;dbl&gt; ## 1 Other Or Not Stated 32897. ## 2 Contusion Or Abrasion 22493. ## 3 Inter Organ Injury 21525. ## 4 Fracture 21497. ## 5 Laceration 18734. ## 6 Strain, Sprain 7609. ## 7 Dislocation 2713. ## 8 Hematoma 2386. ## 9 Avulsion 1778. ## 10 Nerve Damage 1091. ## 11 Poisoning 928. ## 12 Concussion 822. ## 13 Dental Injury 199. ## 14 Hemorrhage 167. ## 15 Crushing 114. ## 16 Dermat Or Conj 84.2 ## 17 Burns, Not Spec 67.2 ## 18 Puncture 67.2 ## 19 Burns, Thermal 34.0 ## 20 Burns, Scald 17.0 Next we’ll we create a plot for the number of accidents for different age and sex: summary &lt;- selected %&gt;% count(age, sex, wt = weight) %&gt;% left_join(y = population, by = c(&quot;age&quot;, &quot;sex&quot;)) %&gt;% mutate(rate = n / population * 1e4) summary %&gt;% ggplot(mapping = aes(x = age, y = rate, color = sex)) + geom_line(na.rm = TRUE) + labs(y = &quot;Injuries per 10,000 people&quot;) The goal is to build an app, which outputs the tables and the plot for different products, which the user selects. "],["prototype.html", "5.4 Prototype", " 5.4 Prototype The first version of the app is a dashboard, where the user can choose a product and get the tables and the plot we have seen in the previous chapter. Code of the ui: ui &lt;- fluidPage( # choose product fluidRow( column( width = 6, selectInput(inputId = &quot;code&quot;, label = &quot;Product&quot;, choices = prod_codes) ) ), # display tables fluidRow( column(width = 4, tableOutput(outputId = &quot;diag&quot;)), column(width = 4, tableOutput(outputId = &quot;body_part&quot;)), column(width = 4, tableOutput(outputId = &quot;location&quot;)) ), # display plot fluidRow( column(width = 12, plotOutput(outputId = &quot;age_sex&quot;)) ) ) Code of the server: server &lt;- function(input, output, session) { # reactive for filtered data frame selected &lt;- reactive( injuries %&gt;% filter(prod_code == input$code) ) # render diagnosis table output$diag &lt;- renderTable( selected() %&gt;% count(diag, wt = weight, sort = TRUE) ) # render body part table output$body_part &lt;- renderTable( selected() %&gt;% count(body_part, wt = weight, sort = TRUE) ) # render location table output$location &lt;- renderTable( selected() %&gt;% count(location, wt = weight, sort = TRUE) ) # reactive for plot data summary &lt;- reactive( selected() %&gt;% count(age, sex, wt = weight) %&gt;% left_join(y = population, by = c(&quot;age&quot;, &quot;sex&quot;)) %&gt;% mutate(rate = n / population * 1e4) ) # render plot output$age_sex &lt;- renderPlot( expr = { summary() %&gt;% ggplot(mapping = aes(x = age, y = n, colour = sex)) + geom_line() + labs(y = &quot;Estimated number of injuries&quot;) }, res = 96 ) } Note: The reactive for plot data is only used once. You could also compute the dataframe when rendering the plot, but it is good practise to seperate computing and plotting. It’s easier to understand and generalise. This prototype is available at https://hadley.shinyapps.io/ms-prototype/. Now we’re going to improve the app step-by-step. "],["polish-tables.html", "5.5 Polish tables", " 5.5 Polish tables The prototype version of the app has very long tables. To make it a little clearer we only want to show the top 5 and lump together all other categories in every table. As an example the diagnosis table for all products would look like this: injuries %&gt;% mutate(diag = fct_lump(fct_infreq(diag), n = 5)) %&gt;% group_by(diag) %&gt;% summarise(n = as.integer(sum(weight))) ## # A tibble: 6 x 2 ## diag n ## &lt;fct&gt; &lt;int&gt; ## 1 Other Or Not Stated 1806436 ## 2 Fracture 1558961 ## 3 Laceration 1432407 ## 4 Strain, Sprain 1432556 ## 5 Contusion Or Abrasion 1451987 ## 6 Other 1929147 "],["rate-vs-count.html", "5.6 Rate vs count", " 5.6 Rate vs count Next step is to give the user the chance to plot the data relative to 10,000 People or in absolute numbers. The new ui looks like this: ui &lt;- fluidPage( fluidRow( column( width = 8, selectInput( inputId = &quot;code&quot;, label = &quot;Product&quot;, choices = prod_codes, width = &quot;100%&quot; ) ), column( width = 2, selectInput(inputId = &quot;y&quot;, label = &quot;Y axis&quot;, choices = c(&quot;rate&quot;, &quot;count&quot;)) ) ), fluidRow( column(width = 4, tableOutput(outputId = &quot;diag&quot;)), column(width = 4, tableOutput(outputId = &quot;body_part&quot;)), column(width = 4, tableOutput(outputId = &quot;location&quot;)) ), fluidRow( column(width = 12, plotOutput(outputId = &quot;age_sex&quot;)) ) ) And plot rendering changes to: server &lt;- function(input, output, session) { ... output$age_sex &lt;- renderPlot( expr = { if (input$y == &quot;count&quot;) { summary() %&gt;% ggplot(mapping = aes(x = age, y = n, colour = sex)) + geom_line() + labs(y = &quot;Estimated number of injuries&quot;) } else { summary() %&gt;% ggplot(mapping = aes(x = age, y = rate, colour = sex)) + geom_line(na.rm = TRUE) + labs(y = &quot;Injuries per 10,000 people&quot;) } }, res = 96 ) } "],["narrative.html", "5.7 Narrative", " 5.7 Narrative Now we want a button to sample an accident story related to the currently chosen product and display it. We add the following ui elements: ui &lt;- fluidPage( ... fluidRow( column( width = 2, actionButton(inputId = &quot;story&quot;, label = &quot;Tell me a story&quot;) ), column(width = 10, textOutput(outputId = &quot;narrative&quot;)) ) ) In the backend we need an eventReactive that triggers, when the button is clicked or the selected data changes: server &lt;- function(input, output, session) { ... narrative_sample &lt;- eventReactive( eventExpr = list(input$story, selected()), valueExpr = selected() %&gt;% pull(narrative) %&gt;% sample(1) ) output$narrative &lt;- renderText(narrative_sample()) } The resulting version of the app is available at https://hadley.shinyapps.io/ms-prototype/. "]]
